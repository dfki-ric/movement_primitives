<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>movement_primitives.dmp API documentation</title>
<meta name="description" content="Dynamical movement primitive variants." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>movement_primitives.dmp</code></h1>
</header>
<section id="section-intro">
<p>Dynamical movement primitive variants.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Dynamical movement primitive variants.&#34;&#34;&#34;
from ._dmp import DMP, dmp_transformation_system
from ._dmp_with_final_velocity import DMPWithFinalVelocity
from ._cartesian_dmp import CartesianDMP
from ._dual_cartesian_dmp import DualCartesianDMP
from ._coupling_terms import (
    CouplingTermObstacleAvoidance2D, CouplingTermObstacleAvoidance3D,
    CouplingTermPos1DToPos1D, CouplingTermPos3DToPos3D,
    CouplingTermDualCartesianOrientation, CouplingTermDualCartesianPose,
    CouplingTermDualCartesianDistance, CouplingTermDualCartesianTrajectory,
    obstacle_avoidance_acceleration_2d, obstacle_avoidance_acceleration_3d)
from ._state_following_dmp import StateFollowingDMP
from ._canonical_system import canonical_system_alpha, phase


__all__ = [
    &#34;DMP&#34;, &#34;dmp_transformation_system&#34;, &#34;DMPWithFinalVelocity&#34;, &#34;CartesianDMP&#34;,
    &#34;DualCartesianDMP&#34;, &#34;CouplingTermPos1DToPos1D&#34;,
    &#34;CouplingTermObstacleAvoidance2D&#34;, &#34;CouplingTermObstacleAvoidance3D&#34;,
    &#34;CouplingTermPos3DToPos3D&#34;, &#34;CouplingTermDualCartesianOrientation&#34;,
    &#34;CouplingTermDualCartesianPose&#34;, &#34;CouplingTermDualCartesianDistance&#34;,
    &#34;CouplingTermDualCartesianTrajectory&#34;, &#34;canonical_system_alpha&#34;, &#34;phase&#34;,
    &#34;obstacle_avoidance_acceleration_2d&#34;, &#34;obstacle_avoidance_acceleration_3d&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="movement_primitives.dmp.canonical_system_alpha"><code class="name flex">
<span>def <span class="ident">canonical_system_alpha</span></span>(<span>goal_z, goal_t, start_t, int_dt=0.001)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute parameter alpha of canonical system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>goal_z</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of phase variable at the end of the execution (&gt; 0).</dd>
<dt><strong><code>goal_t</code></strong> :&ensp;<code>float</code></dt>
<dd>Time at which the execution should be done. Make sure that
goal_t &gt; start_t.</dd>
<dt><strong><code>start_t</code></strong> :&ensp;<code>float</code></dt>
<dd>Time at which the execution should start.</dd>
<dt><strong><code>int_dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.001)</code></dt>
<dd>Time delta that is used internally for integration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the alpha parameter of the canonical system.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If input values are invalid.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def canonical_system_alpha(goal_z, goal_t, start_t, int_dt=0.001):
    &#34;&#34;&#34;Compute parameter alpha of canonical system.

    Parameters
    ----------
    goal_z : float
        Value of phase variable at the end of the execution (&gt; 0).

    goal_t : float
        Time at which the execution should be done. Make sure that
        goal_t &gt; start_t.

    start_t : float
        Time at which the execution should start.

    int_dt : float, optional (default: 0.001)
        Time delta that is used internally for integration.

    Returns
    -------
    alpha : float
        Value of the alpha parameter of the canonical system.

    Raises
    ------
    ValueError
        If input values are invalid.
    &#34;&#34;&#34;
    if goal_z &lt;= 0.0:
        raise ValueError(&#34;Final phase must be &gt; 0!&#34;)
    if start_t &gt;= goal_t:
        raise ValueError(&#34;Goal must be chronologically after start!&#34;)

    execution_time = goal_t - start_t
    n_phases = int(execution_time / int_dt) + 1
    # assert that the execution_time is approximately divisible by int_dt
    assert abs(((n_phases - 1) * int_dt) - execution_time) &lt; 0.05
    return (1.0 - goal_z ** (1.0 / (n_phases - 1))) * (n_phases - 1)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.dmp_transformation_system"><code class="name flex">
<span>def <span class="ident">dmp_transformation_system</span></span>(<span>Y, V, alpha_y, beta_y, goal_y, goal_yd, goal_ydd, execution_time)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute acceleration generated by transformation system of DMP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dmp_transformation_system(Y, V, alpha_y, beta_y, goal_y, goal_yd, goal_ydd,
                              execution_time):
    &#34;&#34;&#34;Compute acceleration generated by transformation system of DMP.&#34;&#34;&#34;
    return (alpha_y * (beta_y * (goal_y - Y) + execution_time * (goal_yd - V))
            ) / execution_time ** 2 + goal_ydd</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.obstacle_avoidance_acceleration_2d"><code class="name flex">
<span>def <span class="ident">obstacle_avoidance_acceleration_2d</span></span>(<span>y, yd, obstacle_position, gamma=1000.0, beta=6.366197723675814)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute acceleration for obstacle avoidance in 2D.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array, shape (&hellip;, 2)</code></dt>
<dd>Current position(s).</dd>
<dt><strong><code>yd</code></strong> :&ensp;<code>array, shape (&hellip;, 2)</code></dt>
<dd>Current velocity / velocities.</dd>
<dt><strong><code>obstacle_position</code></strong> :&ensp;<code>array, shape (2,)</code></dt>
<dd>Position of the point obstacle.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1000)</code></dt>
<dd>Obstacle avoidance parameter.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code>, optional <code>(default: 20 / pi)</code></dt>
<dd>Obstacle avoidance parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdd</code></strong> :&ensp;<code>array, shape (&hellip;, 2)</code></dt>
<dd>Accelerations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obstacle_avoidance_acceleration_2d(
        y, yd, obstacle_position, gamma=1000.0, beta=20.0 / math.pi):
    &#34;&#34;&#34;Compute acceleration for obstacle avoidance in 2D.

    Parameters
    ----------
    y : array, shape (..., 2)
        Current position(s).

    yd : array, shape (..., 2)
        Current velocity / velocities.

    obstacle_position : array, shape (2,)
        Position of the point obstacle.

    gamma : float, optional (default: 1000)
        Obstacle avoidance parameter.

    beta : float, optional (default: 20 / pi)
        Obstacle avoidance parameter.

    Returns
    -------
    cdd : array, shape (..., 2)
        Accelerations.
    &#34;&#34;&#34;
    obstacle_diff = obstacle_position - y
    pad_width = ([[0, 0]] * (y.ndim - 1)) + [[0, 1]]
    obstacle_diff_0 = np.pad(obstacle_diff, pad_width, mode=&#34;constant&#34;,
                             constant_values=0.0)
    yd_0 = np.pad(yd, pad_width, mode=&#34;constant&#34;, constant_values=0.0)
    r = 0.5 * np.pi * pbr.norm_vectors(np.cross(obstacle_diff_0, yd_0))
    R = pbr.matrices_from_compact_axis_angles(r)[..., :2, :2]
    theta_nom = np.einsum(
        &#34;ni,ni-&gt;n&#34;, obstacle_diff.reshape(-1, 2), yd.reshape(-1, 2))
    shape = y.shape[:-1]
    if shape:
        theta_nom = theta_nom.reshape(*shape)
    theta_denom = (np.linalg.norm(obstacle_diff, axis=-1)
                   * np.linalg.norm(yd, axis=-1) + EPSILON)
    theta = np.arccos(theta_nom / theta_denom)
    rotated_velocity = np.einsum(
        &#34;nij,nj-&gt;ni&#34;, R.reshape(-1, 2, 2), yd.reshape(-1, 2))
    if shape:
        rotated_velocity = rotated_velocity.reshape(*(shape + (2,)))
    cdd = (gamma * rotated_velocity
           * (theta * np.exp(-beta * theta))[..., np.newaxis])
    return np.squeeze(cdd)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.obstacle_avoidance_acceleration_3d"><code class="name flex">
<span>def <span class="ident">obstacle_avoidance_acceleration_3d</span></span>(<span>y, yd, obstacle_position, gamma=1000.0, beta=6.366197723675814)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute acceleration for obstacle avoidance in 3D.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array, shape (&hellip;, 3)</code></dt>
<dd>Current position(s).</dd>
<dt><strong><code>yd</code></strong> :&ensp;<code>array, shape (&hellip;, 3)</code></dt>
<dd>Current velocity / velocities.</dd>
<dt><strong><code>obstacle_position</code></strong> :&ensp;<code>array, shape (3,)</code></dt>
<dd>Position of the point obstacle.</dd>
<dt><strong><code>gamma</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1000)</code></dt>
<dd>Obstacle avoidance parameter.</dd>
<dt><strong><code>beta</code></strong> :&ensp;<code>float</code>, optional <code>(default: 20 / pi)</code></dt>
<dd>Obstacle avoidance parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cdd</code></strong> :&ensp;<code>array, shape (&hellip;, 3)</code></dt>
<dd>Accelerations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def obstacle_avoidance_acceleration_3d(
        y, yd, obstacle_position, gamma=1000.0, beta=20.0 / math.pi):
    &#34;&#34;&#34;Compute acceleration for obstacle avoidance in 3D.

    Parameters
    ----------
    y : array, shape (..., 3)
        Current position(s).

    yd : array, shape (..., 3)
        Current velocity / velocities.

    obstacle_position : array, shape (3,)
        Position of the point obstacle.

    gamma : float, optional (default: 1000)
        Obstacle avoidance parameter.

    beta : float, optional (default: 20 / pi)
        Obstacle avoidance parameter.

    Returns
    -------
    cdd : array, shape (..., 3)
        Accelerations.
    &#34;&#34;&#34;
    obstacle_diff = obstacle_position - y
    r = 0.5 * np.pi * pr.norm_vector(np.cross(obstacle_diff, yd))
    R = pr.matrix_from_compact_axis_angle(r)
    theta = np.arccos(
        np.dot(obstacle_diff, yd)
        / (np.linalg.norm(obstacle_diff) * np.linalg.norm(yd) + EPSILON))
    cdd = gamma * np.dot(R, yd) * theta * np.exp(-beta * theta)
    return cdd</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.phase"><code class="name flex">
<span>def <span class="ident">phase</span></span>(<span>t, alpha, goal_t, start_t, int_dt=0.001, eps=1e-10)</span>
</code></dt>
<dd>
<div class="desc"><p>Map time to phase.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>Current time.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the alpha parameter of the canonical system.</dd>
<dt><strong><code>goal_t</code></strong> :&ensp;<code>float</code></dt>
<dd>Time at which the execution should be done.</dd>
<dt><strong><code>start_t</code></strong> :&ensp;<code>float</code></dt>
<dd>Time at which the execution should start.</dd>
<dt><strong><code>int_dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.001)</code></dt>
<dd>Time delta that is used internally for integration.</dd>
<dt><strong><code>eps</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1e-10)</code></dt>
<dd>Small number used to avoid numerical issues.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>z</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of phase variable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def phase(t, alpha, goal_t, start_t, int_dt=0.001, eps=1e-10):
    &#34;&#34;&#34;Map time to phase.

    Parameters
    ----------
    t : float
        Current time.

    alpha : float
        Value of the alpha parameter of the canonical system.

    goal_t : float
        Time at which the execution should be done.

    start_t : float
        Time at which the execution should start.

    int_dt : float, optional (default: 0.001)
        Time delta that is used internally for integration.

    eps : float, optional (default: 1e-10)
        Small number used to avoid numerical issues.

    Returns
    -------
    z : float
        Value of phase variable.
    &#34;&#34;&#34;
    execution_time = goal_t - start_t
    b = max(1.0 - alpha * int_dt / execution_time, eps)
    return b ** ((t - start_t) / int_dt)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="movement_primitives.dmp.CartesianDMP"><code class="flex name class">
<span>class <span class="ident">CartesianDMP</span></span>
<span>(</span><span>execution_time=1.0, dt=0.01, n_weights_per_dim=10, int_dt=0.001)</span>
</code></dt>
<dd>
<div class="desc"><p>Cartesian dynamical movement primitive.</p>
<p>The Cartesian DMP handles orientation and position separately. The
orientation is represented by a quaternion. The quaternion DMP is
implemented according to</p>
<p>A. Ude, B. Nemec, T. Petric, J. Murimoto:
Orientation in Cartesian space dynamic movement primitives (2014),
IEEE International Conference on Robotics and Automation (ICRA),
pp. 2997-3004, doi: 10.1109/ICRA.2014.6907291,
<a href="https://ieeexplore.ieee.org/document/6907291">https://ieeexplore.ieee.org/document/6907291</a></p>
<p>While the dimension of the state space is 7, the dimension of the
velocity, acceleration, and forcing term is 6.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>execution_time</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1)</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.01)</code></dt>
<dd>Time difference between DMP steps.</dd>
<dt><strong><code>n_weights_per_dim</code></strong> :&ensp;<code>int</code>, optional <code>(default: 10)</code></dt>
<dd>Number of weights of the function approximator per dimension.</dd>
<dt><strong><code>int_dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.001)</code></dt>
<dd>Time difference for Euler integration.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>execution_time_</code></strong> :&ensp;<code>float</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt_</code></strong> :&ensp;<code>float</code></dt>
<dd>Time difference between DMP steps. This value can be changed to adapt
the frequency.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CartesianDMP(DMPBase):
    &#34;&#34;&#34;Cartesian dynamical movement primitive.

    The Cartesian DMP handles orientation and position separately. The
    orientation is represented by a quaternion. The quaternion DMP is
    implemented according to

    A. Ude, B. Nemec, T. Petric, J. Murimoto:
    Orientation in Cartesian space dynamic movement primitives (2014),
    IEEE International Conference on Robotics and Automation (ICRA),
    pp. 2997-3004, doi: 10.1109/ICRA.2014.6907291,
    https://ieeexplore.ieee.org/document/6907291

    While the dimension of the state space is 7, the dimension of the
    velocity, acceleration, and forcing term is 6.

    Parameters
    ----------
    execution_time : float, optional (default: 1)
        Execution time of the DMP.

    dt : float, optional (default: 0.01)
        Time difference between DMP steps.

    n_weights_per_dim : int, optional (default: 10)
        Number of weights of the function approximator per dimension.

    int_dt : float, optional (default: 0.001)
        Time difference for Euler integration.

    Attributes
    ----------
    execution_time_ : float
        Execution time of the DMP.

    dt_ : float
        Time difference between DMP steps. This value can be changed to adapt
        the frequency.
    &#34;&#34;&#34;
    def __init__(
            self, execution_time=1.0, dt=0.01, n_weights_per_dim=10,
            int_dt=0.001):
        super(CartesianDMP, self).__init__(7, 6)
        self._execution_time = execution_time
        self.dt_ = dt
        self.n_weights_per_dim = n_weights_per_dim
        self.int_dt = int_dt

        self._init_forcing_term()

        self.alpha_y = 25.0
        self.beta_y = self.alpha_y / 4.0

    def _init_forcing_term(self):
        alpha_z = canonical_system_alpha(
            0.01, self.execution_time_, 0.0, self.int_dt)
        self.forcing_term_pos = ForcingTerm(
            3, self.n_weights_per_dim, self.execution_time_, 0.0, 0.8,
            alpha_z)
        self.forcing_term_rot = ForcingTerm(
            3, self.n_weights_per_dim, self.execution_time_, 0.0, 0.8,
            alpha_z)

    def get_execution_time_(self):
        return self._execution_time

    def set_execution_time_(self, execution_time):
        self._execution_time = execution_time
        weights_pos = self.forcing_term_pos.weights_
        weights_rot = self.forcing_term_rot.weights_
        self._init_forcing_term()
        self.forcing_term_pos.weights_ = weights_pos
        self.forcing_term_rot.weights_ = weights_rot

    execution_time_ = property(get_execution_time_, set_execution_time_)

    def step(self, last_y, last_yd, coupling_term=None,
             step_function=DMP_STEP_FUNCTIONS[DEFAULT_DMP_STEP_FUNCTION],
             quaternion_step_function=CARTESIAN_DMP_STEP_FUNCTIONS[
                 DEFAULT_CARTESIAN_DMP_STEP_FUNCTION]):
        &#34;&#34;&#34;DMP step.

        Parameters
        ----------
        last_y : array, shape (7,)
            Last state.

        last_yd : array, shape (6,)
            Last time derivative of state (velocity).

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        step_function : callable, optional (default: RK4)
            DMP integration function.

        quaternion_step_function : callable, optional (default: cython code if available)
            DMP integration function.

        Returns
        -------
        y : array, shape (14,)
            Next state.

        yd : array, shape (12,)
            Next time derivative of state (velocity).
        &#34;&#34;&#34;
        assert len(last_y) == 7
        assert len(last_yd) == 6

        self.last_t = self.t
        self.t += self.dt_

        # TODO tracking error

        self.current_y[:], self.current_yd[:] = last_y, last_yd
        step_function(
            self.last_t, self.t,
            self.current_y[:3], self.current_yd[:3],
            self.goal_y[:3], self.goal_yd[:3], self.goal_ydd[:3],
            self.start_y[:3], self.start_yd[:3], self.start_ydd[:3],
            self.execution_time_, 0.0,
            self.alpha_y, self.beta_y,
            self.forcing_term_pos,
            coupling_term=coupling_term,
            int_dt=self.int_dt)
        quaternion_step_function(
            self.last_t, self.t,
            self.current_y[3:], self.current_yd[3:],
            self.goal_y[3:], self.goal_yd[3:], self.goal_ydd[3:],
            self.start_y[3:], self.start_yd[3:], self.start_ydd[3:],
            self.execution_time_, 0.0,
            self.alpha_y, self.beta_y,
            self.forcing_term_rot,
            coupling_term=coupling_term,
            int_dt=self.int_dt)
        return np.copy(self.current_y), np.copy(self.current_yd)

    def open_loop(self, run_t=None, coupling_term=None,
                  step_function=DEFAULT_DMP_STEP_FUNCTION,
                  quaternion_step_function=DEFAULT_CARTESIAN_DMP_STEP_FUNCTION):
        &#34;&#34;&#34;Run DMP open loop.

        Parameters
        ----------
        run_t : float, optional (default: execution_time)
            Run time of DMP. Can be shorter or longer than execution_time.

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        step_function : str, optional (default: &#39;rk4&#39;)
            DMP integration function. Possible options: &#39;rk4&#39;, &#39;euler&#39;,
            &#39;euler-cython&#39;, &#39;rk4-cython&#39;.

        quaternion_step_function : str, optional (default: &#39;cython&#39; if available)
            DMP integration function. Possible options: &#39;python&#39;, &#39;cython&#39;.

        Returns
        -------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, 7)
            State at each step.
        &#34;&#34;&#34;
        try:
            step_function = DMP_STEP_FUNCTIONS[step_function]
        except KeyError:
            raise ValueError(
                f&#34;Step function must be in &#34;
                f&#34;{DMP_STEP_FUNCTIONS.keys()}.&#34;)
        T, Yp = dmp_open_loop(
            self.execution_time_, 0.0, self.dt_,
            self.start_y[:3], self.goal_y[:3],
            self.alpha_y, self.beta_y,
            self.forcing_term_pos,
            coupling_term,
            run_t, self.int_dt,
            step_function=step_function)
        try:
            quaternion_step_function = CARTESIAN_DMP_STEP_FUNCTIONS[
                quaternion_step_function]
        except KeyError:
            raise ValueError(
                f&#34;Step function must be in &#34;
                f&#34;{CARTESIAN_DMP_STEP_FUNCTIONS.keys()}.&#34;)
        _, Yr = dmp_open_loop_quaternion(
            self.execution_time_, 0.0, self.dt_,
            self.start_y[3:], self.goal_y[3:],
            self.alpha_y, self.beta_y,
            self.forcing_term_rot,
            coupling_term,
            run_t, self.int_dt,
            quaternion_step_function)
        return T, np.hstack((Yp, Yr))

    def imitate(self, T, Y, regularization_coefficient=0.0,
                allow_final_velocity=False):
        &#34;&#34;&#34;Imitate demonstration.

        Parameters
        ----------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, 7)
            State at each step.

        regularization_coefficient : float, optional (default: 0)
            Regularization coefficient for regression.

        allow_final_velocity : bool, optional (default: False)
            Allow a final velocity.
        &#34;&#34;&#34;
        self.forcing_term_pos.weights_[:, :] = dmp_imitate(
            T, Y[:, :3],
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term_pos.overlap,
            alpha_z=self.forcing_term_pos.alpha_z,
            allow_final_velocity=allow_final_velocity)[0]
        self.forcing_term_rot.weights_[:, :] = dmp_quaternion_imitation(
            T, Y[:, 3:],
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term_rot.overlap,
            alpha_z=self.forcing_term_rot.alpha_z,
            allow_final_velocity=allow_final_velocity)[0]

        self.configure(start_y=Y[0], goal_y=Y[-1])

    def get_weights(self):
        &#34;&#34;&#34;Get weight vector of DMP.

        Returns
        -------
        weights : array, shape (6 * n_weights_per_dim,)
            Current weights of the DMP.
        &#34;&#34;&#34;
        return np.concatenate((self.forcing_term_pos.weights_.ravel(),
                               self.forcing_term_rot.weights_.ravel()))

    def set_weights(self, weights):
        &#34;&#34;&#34;Set weight vector of DMP.

        Parameters
        ----------
        weights : array, shape (6 * n_weights_per_dim,)
            New weights of the DMP.
        &#34;&#34;&#34;
        n_pos_weights = self.forcing_term_pos.weights_.size
        self.forcing_term_pos.weights_[:, :] = weights[:n_pos_weights].reshape(
            -1, self.n_weights_per_dim)
        self.forcing_term_rot.weights_[:, :] = weights[n_pos_weights:].reshape(
            -1, self.n_weights_per_dim)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>movement_primitives.dmp._base.DMPBase</li>
<li><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="movement_primitives.dmp.CartesianDMP.execution_time_"><code class="name">var <span class="ident">execution_time_</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CartesianDMP.get_execution_time_"><code class="name flex">
<span>def <span class="ident">get_execution_time_</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CartesianDMP.get_weights"><code class="name flex">
<span>def <span class="ident">get_weights</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get weight vector of DMP.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>weights</code></strong> :&ensp;<code>array, shape (6 * n_weights_per_dim,)</code></dt>
<dd>Current weights of the DMP.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_weights(self):
    &#34;&#34;&#34;Get weight vector of DMP.

    Returns
    -------
    weights : array, shape (6 * n_weights_per_dim,)
        Current weights of the DMP.
    &#34;&#34;&#34;
    return np.concatenate((self.forcing_term_pos.weights_.ravel(),
                           self.forcing_term_rot.weights_.ravel()))</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CartesianDMP.imitate"><code class="name flex">
<span>def <span class="ident">imitate</span></span>(<span>self, T, Y, regularization_coefficient=0.0, allow_final_velocity=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imitate demonstration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, 7)</code></dt>
<dd>State at each step.</dd>
<dt><strong><code>regularization_coefficient</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Regularization coefficient for regression.</dd>
<dt><strong><code>allow_final_velocity</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Allow a final velocity.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imitate(self, T, Y, regularization_coefficient=0.0,
            allow_final_velocity=False):
    &#34;&#34;&#34;Imitate demonstration.

    Parameters
    ----------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, 7)
        State at each step.

    regularization_coefficient : float, optional (default: 0)
        Regularization coefficient for regression.

    allow_final_velocity : bool, optional (default: False)
        Allow a final velocity.
    &#34;&#34;&#34;
    self.forcing_term_pos.weights_[:, :] = dmp_imitate(
        T, Y[:, :3],
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term_pos.overlap,
        alpha_z=self.forcing_term_pos.alpha_z,
        allow_final_velocity=allow_final_velocity)[0]
    self.forcing_term_rot.weights_[:, :] = dmp_quaternion_imitation(
        T, Y[:, 3:],
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term_rot.overlap,
        alpha_z=self.forcing_term_rot.alpha_z,
        allow_final_velocity=allow_final_velocity)[0]

    self.configure(start_y=Y[0], goal_y=Y[-1])</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CartesianDMP.open_loop"><code class="name flex">
<span>def <span class="ident">open_loop</span></span>(<span>self, run_t=None, coupling_term=None, step_function='rk4-cython', quaternion_step_function='cython')</span>
</code></dt>
<dd>
<div class="desc"><p>Run DMP open loop.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>run_t</code></strong> :&ensp;<code>float</code>, optional <code>(default: execution_time)</code></dt>
<dd>Run time of DMP. Can be shorter or longer than execution_time.</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
<dt><strong><code>step_function</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'rk4')</code></dt>
<dd>DMP integration function. Possible options: 'rk4', 'euler',
'euler-cython', 'rk4-cython'.</dd>
<dt><strong><code>quaternion_step_function</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'cython' if available)</code></dt>
<dd>DMP integration function. Possible options: 'python', 'cython'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, 7)</code></dt>
<dd>State at each step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_loop(self, run_t=None, coupling_term=None,
              step_function=DEFAULT_DMP_STEP_FUNCTION,
              quaternion_step_function=DEFAULT_CARTESIAN_DMP_STEP_FUNCTION):
    &#34;&#34;&#34;Run DMP open loop.

    Parameters
    ----------
    run_t : float, optional (default: execution_time)
        Run time of DMP. Can be shorter or longer than execution_time.

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    step_function : str, optional (default: &#39;rk4&#39;)
        DMP integration function. Possible options: &#39;rk4&#39;, &#39;euler&#39;,
        &#39;euler-cython&#39;, &#39;rk4-cython&#39;.

    quaternion_step_function : str, optional (default: &#39;cython&#39; if available)
        DMP integration function. Possible options: &#39;python&#39;, &#39;cython&#39;.

    Returns
    -------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, 7)
        State at each step.
    &#34;&#34;&#34;
    try:
        step_function = DMP_STEP_FUNCTIONS[step_function]
    except KeyError:
        raise ValueError(
            f&#34;Step function must be in &#34;
            f&#34;{DMP_STEP_FUNCTIONS.keys()}.&#34;)
    T, Yp = dmp_open_loop(
        self.execution_time_, 0.0, self.dt_,
        self.start_y[:3], self.goal_y[:3],
        self.alpha_y, self.beta_y,
        self.forcing_term_pos,
        coupling_term,
        run_t, self.int_dt,
        step_function=step_function)
    try:
        quaternion_step_function = CARTESIAN_DMP_STEP_FUNCTIONS[
            quaternion_step_function]
    except KeyError:
        raise ValueError(
            f&#34;Step function must be in &#34;
            f&#34;{CARTESIAN_DMP_STEP_FUNCTIONS.keys()}.&#34;)
    _, Yr = dmp_open_loop_quaternion(
        self.execution_time_, 0.0, self.dt_,
        self.start_y[3:], self.goal_y[3:],
        self.alpha_y, self.beta_y,
        self.forcing_term_rot,
        coupling_term,
        run_t, self.int_dt,
        quaternion_step_function)
    return T, np.hstack((Yp, Yr))</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CartesianDMP.set_execution_time_"><code class="name flex">
<span>def <span class="ident">set_execution_time_</span></span>(<span>self, execution_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_execution_time_(self, execution_time):
    self._execution_time = execution_time
    weights_pos = self.forcing_term_pos.weights_
    weights_rot = self.forcing_term_rot.weights_
    self._init_forcing_term()
    self.forcing_term_pos.weights_ = weights_pos
    self.forcing_term_rot.weights_ = weights_rot</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CartesianDMP.set_weights"><code class="name flex">
<span>def <span class="ident">set_weights</span></span>(<span>self, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Set weight vector of DMP.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>weights</code></strong> :&ensp;<code>array, shape (6 * n_weights_per_dim,)</code></dt>
<dd>New weights of the DMP.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_weights(self, weights):
    &#34;&#34;&#34;Set weight vector of DMP.

    Parameters
    ----------
    weights : array, shape (6 * n_weights_per_dim,)
        New weights of the DMP.
    &#34;&#34;&#34;
    n_pos_weights = self.forcing_term_pos.weights_.size
    self.forcing_term_pos.weights_[:, :] = weights[:n_pos_weights].reshape(
        -1, self.n_weights_per_dim)
    self.forcing_term_rot.weights_[:, :] = weights[n_pos_weights:].reshape(
        -1, self.n_weights_per_dim)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CartesianDMP.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, last_y, last_yd, coupling_term=None, step_function=&lt;cyfunction dmp_step_rk4&gt;, quaternion_step_function=&lt;cyfunction dmp_step_quaternion&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>DMP step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>last_y</code></strong> :&ensp;<code>array, shape (7,)</code></dt>
<dd>Last state.</dd>
<dt><strong><code>last_yd</code></strong> :&ensp;<code>array, shape (6,)</code></dt>
<dd>Last time derivative of state (velocity).</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
<dt><strong><code>step_function</code></strong> :&ensp;<code>callable</code>, optional <code>(default: RK4)</code></dt>
<dd>DMP integration function.</dd>
<dt><strong><code>quaternion_step_function</code></strong> :&ensp;<code>callable</code>, optional <code>(default: cython code if available)</code></dt>
<dd>DMP integration function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array, shape (14,)</code></dt>
<dd>Next state.</dd>
<dt><strong><code>yd</code></strong> :&ensp;<code>array, shape (12,)</code></dt>
<dd>Next time derivative of state (velocity).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, last_y, last_yd, coupling_term=None,
         step_function=DMP_STEP_FUNCTIONS[DEFAULT_DMP_STEP_FUNCTION],
         quaternion_step_function=CARTESIAN_DMP_STEP_FUNCTIONS[
             DEFAULT_CARTESIAN_DMP_STEP_FUNCTION]):
    &#34;&#34;&#34;DMP step.

    Parameters
    ----------
    last_y : array, shape (7,)
        Last state.

    last_yd : array, shape (6,)
        Last time derivative of state (velocity).

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    step_function : callable, optional (default: RK4)
        DMP integration function.

    quaternion_step_function : callable, optional (default: cython code if available)
        DMP integration function.

    Returns
    -------
    y : array, shape (14,)
        Next state.

    yd : array, shape (12,)
        Next time derivative of state (velocity).
    &#34;&#34;&#34;
    assert len(last_y) == 7
    assert len(last_yd) == 6

    self.last_t = self.t
    self.t += self.dt_

    # TODO tracking error

    self.current_y[:], self.current_yd[:] = last_y, last_yd
    step_function(
        self.last_t, self.t,
        self.current_y[:3], self.current_yd[:3],
        self.goal_y[:3], self.goal_yd[:3], self.goal_ydd[:3],
        self.start_y[:3], self.start_yd[:3], self.start_ydd[:3],
        self.execution_time_, 0.0,
        self.alpha_y, self.beta_y,
        self.forcing_term_pos,
        coupling_term=coupling_term,
        int_dt=self.int_dt)
    quaternion_step_function(
        self.last_t, self.t,
        self.current_y[3:], self.current_yd[3:],
        self.goal_y[3:], self.goal_yd[3:], self.goal_ydd[3:],
        self.start_y[3:], self.start_yd[3:], self.start_ydd[3:],
        self.execution_time_, 0.0,
        self.alpha_y, self.beta_y,
        self.forcing_term_rot,
        coupling_term=coupling_term,
        int_dt=self.int_dt)
    return np.copy(self.current_y), np.copy(self.current_yd)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></b></code>:
<ul class="hlist">
<li><code><a title="movement_primitives.base.PointToPointMovement.configure" href="../base.html#movement_primitives.base.PointToPointMovement.configure">configure</a></code></li>
<li><code><a title="movement_primitives.base.PointToPointMovement.n_steps_open_loop" href="../base.html#movement_primitives.base.PointToPointMovement.n_steps_open_loop">n_steps_open_loop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianDistance"><code class="flex name class">
<span>class <span class="ident">CouplingTermDualCartesianDistance</span></span>
<span>(</span><span>desired_distance, lf, k=1.0, c1=1.0, c2=30.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Couples distance between 3D positions of a dual Cartesian DMP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermDualCartesianDistance:  # for DualCartesianDMP
    &#34;&#34;&#34;Couples distance between 3D positions of a dual Cartesian DMP.&#34;&#34;&#34;
    def __init__(self, desired_distance, lf, k=1.0, c1=1.0, c2=30.0):
        self.desired_distance = desired_distance
        self.lf = lf
        self.k = k
        self.c1 = c1
        self.c2 = c2

    def coupling(self, y, yd=None):
        actual_distance = y[:3] - y[7:10]
        desired_distance = (np.abs(self.desired_distance) * actual_distance
                            / np.linalg.norm(actual_distance))
        F12 = self.k * (desired_distance - actual_distance)
        F21 = -F12
        C12 = self.c1 * F12 * self.lf[0]
        C21 = self.c1 * F21 * self.lf[1]
        C12dot = F12 * self.c2 * self.lf[0]
        C21dot = F21 * self.c2 * self.lf[1]
        return (np.hstack([C12, np.zeros(3), C21, np.zeros(3)]),
                np.hstack([C12dot, np.zeros(3), C21dot, np.zeros(3)]))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianDistance.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd=None):
    actual_distance = y[:3] - y[7:10]
    desired_distance = (np.abs(self.desired_distance) * actual_distance
                        / np.linalg.norm(actual_distance))
    F12 = self.k * (desired_distance - actual_distance)
    F21 = -F12
    C12 = self.c1 * F12 * self.lf[0]
    C21 = self.c1 * F21 * self.lf[1]
    C12dot = F12 * self.c2 * self.lf[0]
    C21dot = F21 * self.c2 * self.lf[1]
    return (np.hstack([C12, np.zeros(3), C21, np.zeros(3)]),
            np.hstack([C12dot, np.zeros(3), C21dot, np.zeros(3)]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianOrientation"><code class="flex name class">
<span>class <span class="ident">CouplingTermDualCartesianOrientation</span></span>
<span>(</span><span>desired_distance, lf, k=1.0, c1=1.0, c2=30.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Couples orientations of dual Cartesian DMP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermDualCartesianOrientation:  # for DualCartesianDMP
    &#34;&#34;&#34;Couples orientations of dual Cartesian DMP.&#34;&#34;&#34;
    def __init__(self, desired_distance, lf, k=1.0, c1=1.0, c2=30.0):
        self.desired_distance = desired_distance
        self.lf = lf
        self.k = k
        self.c1 = c1
        self.c2 = c2

    def coupling(self, y, yd=None):
        q1 = y[3:7]
        q2 = y[10:]
        actual_distance = pr.compact_axis_angle_from_quaternion(
            pr.concatenate_quaternions(q1, pr.q_conj(q2)))
        actual_distance_norm = np.linalg.norm(actual_distance)
        if actual_distance_norm &lt; np.finfo(&#34;float&#34;).eps:
            desired_distance = (np.abs(self.desired_distance)
                                * np.array([0.0, 0.0, 1.0]))
        else:
            desired_distance = (np.abs(self.desired_distance) * actual_distance
                                / actual_distance_norm)
        F12 = self.k * (desired_distance - actual_distance)
        F21 = -F12
        C12 = self.c1 * F12 * self.lf[0]
        C21 = self.c1 * F21 * self.lf[1]
        C12dot = F12 * self.c2 * self.lf[0]
        C21dot = F21 * self.c2 * self.lf[1]
        return (np.hstack([np.zeros(3), C12, np.zeros(3), C21]),
                np.hstack([np.zeros(3), C12dot, np.zeros(3), C21dot]))</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianOrientation.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd=None):
    q1 = y[3:7]
    q2 = y[10:]
    actual_distance = pr.compact_axis_angle_from_quaternion(
        pr.concatenate_quaternions(q1, pr.q_conj(q2)))
    actual_distance_norm = np.linalg.norm(actual_distance)
    if actual_distance_norm &lt; np.finfo(&#34;float&#34;).eps:
        desired_distance = (np.abs(self.desired_distance)
                            * np.array([0.0, 0.0, 1.0]))
    else:
        desired_distance = (np.abs(self.desired_distance) * actual_distance
                            / actual_distance_norm)
    F12 = self.k * (desired_distance - actual_distance)
    F21 = -F12
    C12 = self.c1 * F12 * self.lf[0]
    C21 = self.c1 * F21 * self.lf[1]
    C12dot = F12 * self.c2 * self.lf[0]
    C21dot = F21 * self.c2 * self.lf[1]
    return (np.hstack([np.zeros(3), C12, np.zeros(3), C21]),
            np.hstack([np.zeros(3), C12dot, np.zeros(3), C21dot]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianPose"><code class="flex name class">
<span>class <span class="ident">CouplingTermDualCartesianPose</span></span>
<span>(</span><span>desired_distance, lf, couple_position=True, couple_orientation=True, k=1.0, c1=1.0, c2=30.0, verbose=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Couples relative poses of dual Cartesian DMP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermDualCartesianPose:  # for DualCartesianDMP
    &#34;&#34;&#34;Couples relative poses of dual Cartesian DMP.&#34;&#34;&#34;
    def __init__(self, desired_distance, lf, couple_position=True,
                 couple_orientation=True, k=1.0, c1=1.0, c2=30.0, verbose=0):
        self.desired_distance = desired_distance
        self.lf = lf
        self.couple_position = couple_position
        self.couple_orientation = couple_orientation
        self.k = k
        self.c1 = c1
        self.c2 = c2
        self.verbose = verbose

    def coupling(self, y, yd=None):
        return self.couple_distance(
            y, yd, self.k, self.c1, self.c2, self.lf, self.desired_distance,
            self.couple_position, self.couple_orientation)

    def couple_distance(self, y, yd, k, c1, c2, lf, desired_distance,
                        couple_position, couple_orientation):
        damping = 2.0 * np.sqrt(k * c2)

        vel_left = yd[:6]
        vel_right = yd[6:]

        left2base = pt.transform_from_pq(y[:7])
        right2left_pq = self._right2left_pq(y)

        actual_distance_pos = right2left_pq[:3]
        actual_distance_rot = right2left_pq[3:]

        desired_distance = pt.pq_from_transform(desired_distance)
        desired_distance_pos = desired_distance[:3]
        desired_distance_rot = desired_distance[3:]

        if self.verbose:
            print(&#34;Desired vs. actual:&#34;)
            print(np.round(desired_distance, 2))
            print(np.round(right2left_pq, 2))

        error_pos = desired_distance_pos - actual_distance_pos
        F12_pos = -k * error_pos
        F21_pos = k * error_pos

        F12_pos = pt.transform(left2base, pt.vector_to_direction(F12_pos))[:3]
        F21_pos = pt.transform(left2base, pt.vector_to_direction(F21_pos))[:3]

        C12_pos = lf[0] * c1 * F12_pos
        C21_pos = lf[1] * c1 * F21_pos

        C12dot_pos = lf[0] * (c2 * F12_pos - damping * vel_left[:3])
        C21dot_pos = lf[1] * (c2 * F21_pos - damping * vel_right[:3])

        if not couple_position:
            C12_pos *= 0
            C21_pos *= 0
            C12dot_pos *= 0
            C21dot_pos *= 0

        error_rot = pr.compact_axis_angle_from_quaternion(
            pr.concatenate_quaternions(desired_distance_rot,
                                       pr.q_conj(actual_distance_rot)))
        F12_rot = -k * error_rot
        F21_rot = k * error_rot

        F12_rot = pt.transform(left2base, pt.vector_to_direction(F12_rot))[:3]
        F21_rot = pt.transform(left2base, pt.vector_to_direction(F21_rot))[:3]

        C12_rot = lf[0] * c1 * F12_rot
        C21_rot = lf[1] * c1 * F21_rot

        C12dot_rot = lf[0] * (c2 * F12_rot - damping * vel_left[3:])
        C21dot_rot = lf[1] * (c2 * F21_rot - damping * vel_right[3:])

        if not couple_orientation:
            C12_rot *= 0
            C21_rot *= 0
            C12dot_rot *= 0
            C21dot_rot *= 0

        return (np.hstack([C12_pos, C12_rot, C21_pos, C21_rot]),
                np.hstack([C12dot_pos, C12dot_rot, C21dot_pos, C21dot_rot]))

    def _right2left_pq(self, y):
        left2base = pt.transform_from_pq(y[:7])
        right2base = pt.transform_from_pq(y[7:])
        base2left = pt.invert_transform(left2base)
        right2left = pt.concat(right2base, base2left)
        right2left_pq = pt.pq_from_transform(right2left)
        return right2left_pq</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>movement_primitives.dmp._coupling_terms.CouplingTermDualCartesianTrajectory</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianPose.couple_distance"><code class="name flex">
<span>def <span class="ident">couple_distance</span></span>(<span>self, y, yd, k, c1, c2, lf, desired_distance, couple_position, couple_orientation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def couple_distance(self, y, yd, k, c1, c2, lf, desired_distance,
                    couple_position, couple_orientation):
    damping = 2.0 * np.sqrt(k * c2)

    vel_left = yd[:6]
    vel_right = yd[6:]

    left2base = pt.transform_from_pq(y[:7])
    right2left_pq = self._right2left_pq(y)

    actual_distance_pos = right2left_pq[:3]
    actual_distance_rot = right2left_pq[3:]

    desired_distance = pt.pq_from_transform(desired_distance)
    desired_distance_pos = desired_distance[:3]
    desired_distance_rot = desired_distance[3:]

    if self.verbose:
        print(&#34;Desired vs. actual:&#34;)
        print(np.round(desired_distance, 2))
        print(np.round(right2left_pq, 2))

    error_pos = desired_distance_pos - actual_distance_pos
    F12_pos = -k * error_pos
    F21_pos = k * error_pos

    F12_pos = pt.transform(left2base, pt.vector_to_direction(F12_pos))[:3]
    F21_pos = pt.transform(left2base, pt.vector_to_direction(F21_pos))[:3]

    C12_pos = lf[0] * c1 * F12_pos
    C21_pos = lf[1] * c1 * F21_pos

    C12dot_pos = lf[0] * (c2 * F12_pos - damping * vel_left[:3])
    C21dot_pos = lf[1] * (c2 * F21_pos - damping * vel_right[:3])

    if not couple_position:
        C12_pos *= 0
        C21_pos *= 0
        C12dot_pos *= 0
        C21dot_pos *= 0

    error_rot = pr.compact_axis_angle_from_quaternion(
        pr.concatenate_quaternions(desired_distance_rot,
                                   pr.q_conj(actual_distance_rot)))
    F12_rot = -k * error_rot
    F21_rot = k * error_rot

    F12_rot = pt.transform(left2base, pt.vector_to_direction(F12_rot))[:3]
    F21_rot = pt.transform(left2base, pt.vector_to_direction(F21_rot))[:3]

    C12_rot = lf[0] * c1 * F12_rot
    C21_rot = lf[1] * c1 * F21_rot

    C12dot_rot = lf[0] * (c2 * F12_rot - damping * vel_left[3:])
    C21dot_rot = lf[1] * (c2 * F21_rot - damping * vel_right[3:])

    if not couple_orientation:
        C12_rot *= 0
        C21_rot *= 0
        C12dot_rot *= 0
        C21dot_rot *= 0

    return (np.hstack([C12_pos, C12_rot, C21_pos, C21_rot]),
            np.hstack([C12dot_pos, C12dot_rot, C21dot_pos, C21dot_rot]))</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianPose.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd=None):
    return self.couple_distance(
        y, yd, self.k, self.c1, self.c2, self.lf, self.desired_distance,
        self.couple_position, self.couple_orientation)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianTrajectory"><code class="flex name class">
<span>class <span class="ident">CouplingTermDualCartesianTrajectory</span></span>
<span>(</span><span>offset, lf, dt, couple_position=True, couple_orientation=True, k=1.0, c1=1.0, c2=30.0, verbose=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Couples relative pose in dual Cartesian DMP with a given trajectory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermDualCartesianTrajectory(CouplingTermDualCartesianPose):  # for DualCartesianDMP
    &#34;&#34;&#34;Couples relative pose in dual Cartesian DMP with a given trajectory.&#34;&#34;&#34;
    def __init__(self, offset, lf, dt, couple_position=True,
                 couple_orientation=True, k=1.0, c1=1.0, c2=30.0, verbose=1):
        self.offset = offset
        self.lf = lf
        self.dt = dt
        self.couple_position = couple_position
        self.couple_orientation = couple_orientation
        self.k = k
        self.c1 = c1
        self.c2 = c2
        self.verbose = verbose

    def imitate(self, T, Y):
        distance = np.empty((len(Y), 7))
        for t in range(len(Y)):
            distance[t] = self._right2left_pq(Y[t])
        self.desired_distance_per_dimension = [
            interp1d(T, distance[:, d], bounds_error=False,
                     fill_value=&#34;extrapolate&#34;)
            for d in range(distance.shape[1])
        ]
        self.t = 0.0

    def coupling(self, y, yd=None):
        desired_distance = np.empty(len(self.desired_distance_per_dimension))
        for d in range(len(desired_distance)):
            desired_distance[d] = self.desired_distance_per_dimension[d](self.t)
        desired_distance += self.offset
        self.t += self.dt
        return self.couple_distance(
            y, yd, self.k, self.c1, self.c2, self.lf,
            pt.transform_from_pq(desired_distance), self.couple_position,
            self.couple_orientation)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>movement_primitives.dmp._coupling_terms.CouplingTermDualCartesianPose</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianTrajectory.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd=None):
    desired_distance = np.empty(len(self.desired_distance_per_dimension))
    for d in range(len(desired_distance)):
        desired_distance[d] = self.desired_distance_per_dimension[d](self.t)
    desired_distance += self.offset
    self.t += self.dt
    return self.couple_distance(
        y, yd, self.k, self.c1, self.c2, self.lf,
        pt.transform_from_pq(desired_distance), self.couple_position,
        self.couple_orientation)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.CouplingTermDualCartesianTrajectory.imitate"><code class="name flex">
<span>def <span class="ident">imitate</span></span>(<span>self, T, Y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imitate(self, T, Y):
    distance = np.empty((len(Y), 7))
    for t in range(len(Y)):
        distance[t] = self._right2left_pq(Y[t])
    self.desired_distance_per_dimension = [
        interp1d(T, distance[:, d], bounds_error=False,
                 fill_value=&#34;extrapolate&#34;)
        for d in range(distance.shape[1])
    ]
    self.t = 0.0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermObstacleAvoidance2D"><code class="flex name class">
<span>class <span class="ident">CouplingTermObstacleAvoidance2D</span></span>
<span>(</span><span>obstacle_position, gamma=1000.0, beta=6.366197723675814, fast=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Coupling term for obstacle avoidance in 2D.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermObstacleAvoidance2D:  # for DMP
    &#34;&#34;&#34;Coupling term for obstacle avoidance in 2D.&#34;&#34;&#34;
    def __init__(self, obstacle_position, gamma=1000.0, beta=20.0 / math.pi,
                 fast=False):
        self.obstacle_position = obstacle_position
        self.gamma = gamma
        self.beta = beta
        if fast and obstacle_avoidance_acceleration_2d_fast_available:
            self.step_function = obstacle_avoidance_acceleration_2d_fast
        else:
            self.step_function = obstacle_avoidance_acceleration_2d

    def coupling(self, y, yd):
        cdd = self.step_function(
            y, yd, self.obstacle_position, self.gamma, self.beta)
        return np.zeros_like(cdd), cdd</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermObstacleAvoidance2D.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd):
    cdd = self.step_function(
        y, yd, self.obstacle_position, self.gamma, self.beta)
    return np.zeros_like(cdd), cdd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermObstacleAvoidance3D"><code class="flex name class">
<span>class <span class="ident">CouplingTermObstacleAvoidance3D</span></span>
<span>(</span><span>obstacle_position, gamma=1000.0, beta=6.366197723675814)</span>
</code></dt>
<dd>
<div class="desc"><p>Coupling term for obstacle avoidance in 3D.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermObstacleAvoidance3D:  # for DMP
    &#34;&#34;&#34;Coupling term for obstacle avoidance in 3D.&#34;&#34;&#34;
    def __init__(self, obstacle_position, gamma=1000.0, beta=20.0 / math.pi):
        self.obstacle_position = obstacle_position
        self.gamma = gamma
        self.beta = beta

    def coupling(self, y, yd):
        cdd = obstacle_avoidance_acceleration_3d(
            y, yd, self.obstacle_position, self.gamma, self.beta)
        return np.zeros_like(cdd), cdd</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermObstacleAvoidance3D.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd):
    cdd = obstacle_avoidance_acceleration_3d(
        y, yd, self.obstacle_position, self.gamma, self.beta)
    return np.zeros_like(cdd), cdd</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermPos1DToPos1D"><code class="flex name class">
<span>class <span class="ident">CouplingTermPos1DToPos1D</span></span>
<span>(</span><span>desired_distance, lf, k=1.0, c1=100.0, c2=30.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Couples position components of a 2D DMP with a virtual spring.</p>
<p>A. Gams, B. Nemec, L. Zlajpah, M. Wchter, T. Asfour, A. Ude:
Modulation of Motor Primitives using Force Feedback: Interaction with
the Environment and Bimanual Tasks (2013), IROS,
<a href="https://h2t.anthropomatik.kit.edu/pdf/Gams2013.pdf">https://h2t.anthropomatik.kit.edu/pdf/Gams2013.pdf</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>desired_distance</code></strong> :&ensp;<code>float</code></dt>
<dd>Desired distance between components.</dd>
<dt><strong><code>lf</code></strong> :&ensp;<code>array-like, shape (2,)</code></dt>
<dd>Binary values that indicate which DMP(s) will be adapted.
The variable lf defines the relation leader-follower. If lf[0] = lf[1],
then both robots will adapt their trajectories to follow average
trajectories at the defined distance dd between them [..]. On the other
hand, if lf[0] = 0 and lf[1] = 1, only DMP1 will change the trajectory
to match the trajectory of DMP0, again at the distance dd and again
only after learning. Vice versa applies as well. Leader-follower
relation can be determined by a higher-level planner [..].</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1)</code></dt>
<dd>Virtual spring constant that couples the positions.</dd>
<dt><strong><code>c1</code></strong> :&ensp;<code>float</code>, optional <code>(default: 100)</code></dt>
<dd>Scaling factor for spring forces in the velocity component and
acceleration component.</dd>
<dt><strong><code>c2</code></strong> :&ensp;<code>float</code>, optional <code>(default: 30)</code></dt>
<dd>Scaling factor for spring forces in the acceleration component.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermPos1DToPos1D:
    &#34;&#34;&#34;Couples position components of a 2D DMP with a virtual spring.

    A. Gams, B. Nemec, L. Zlajpah, M. Wchter, T. Asfour, A. Ude:
    Modulation of Motor Primitives using Force Feedback: Interaction with
    the Environment and Bimanual Tasks (2013), IROS,
    https://h2t.anthropomatik.kit.edu/pdf/Gams2013.pdf

    Parameters
    ----------
    desired_distance : float
        Desired distance between components.

    lf : array-like, shape (2,)
        Binary values that indicate which DMP(s) will be adapted.
        The variable lf defines the relation leader-follower. If lf[0] = lf[1],
        then both robots will adapt their trajectories to follow average
        trajectories at the defined distance dd between them [..]. On the other
        hand, if lf[0] = 0 and lf[1] = 1, only DMP1 will change the trajectory
        to match the trajectory of DMP0, again at the distance dd and again
        only after learning. Vice versa applies as well. Leader-follower
        relation can be determined by a higher-level planner [..].

    k : float, optional (default: 1)
        Virtual spring constant that couples the positions.

    c1 : float, optional (default: 100)
        Scaling factor for spring forces in the velocity component and
        acceleration component.

    c2 : float, optional (default: 30)
        Scaling factor for spring forces in the acceleration component.
    &#34;&#34;&#34;
    def __init__(self, desired_distance, lf, k=1.0, c1=100.0, c2=30.0):
        self.desired_distance = desired_distance
        self.lf = lf
        self.k = k
        self.c1 = c1
        self.c2 = c2

    def coupling(self, y, yd=None):
        da = y[0] - y[1]
        F12 = self.k * (-self.desired_distance - da)
        F21 = -F12
        C12 = self.c1 * F12 * self.lf[0]
        C21 = self.c1 * F21 * self.lf[1]
        C12dot = self.c2 * self.c1 * F12 * self.lf[0]
        C21dot = self.c2 * self.c1 * F21 * self.lf[1]
        return np.array([C12, C21]), np.array([C12dot, C21dot])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermPos1DToPos1D.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd=None):
    da = y[0] - y[1]
    F12 = self.k * (-self.desired_distance - da)
    F21 = -F12
    C12 = self.c1 * F12 * self.lf[0]
    C21 = self.c1 * F21 * self.lf[1]
    C12dot = self.c2 * self.c1 * F12 * self.lf[0]
    C21dot = self.c2 * self.c1 * F21 * self.lf[1]
    return np.array([C12, C21]), np.array([C12dot, C21dot])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.CouplingTermPos3DToPos3D"><code class="flex name class">
<span>class <span class="ident">CouplingTermPos3DToPos3D</span></span>
<span>(</span><span>desired_distance, lf, k=1.0, c1=1.0, c2=30.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Couples position components of a 6D DMP with a virtual spring in 3D.</p>
<p>A. Gams, B. Nemec, L. Zlajpah, M. Wchter, T. Asfour, A. Ude:
Modulation of Motor Primitives using Force Feedback: Interaction with
the Environment and Bimanual Tasks (2013), IROS,
<a href="https://h2t.anthropomatik.kit.edu/pdf/Gams2013.pdf">https://h2t.anthropomatik.kit.edu/pdf/Gams2013.pdf</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>desired_distance</code></strong> :&ensp;<code>array, shape (3,)</code></dt>
<dd>Desired distance between components.</dd>
<dt><strong><code>lf</code></strong> :&ensp;<code>array-like, shape (2,)</code></dt>
<dd>Binary values that indicate which DMP(s) will be adapted.
The variable lf defines the relation leader-follower. If lf[0] = lf[1],
then both robots will adapt their trajectories to follow average
trajectories at the defined distance dd between them [..]. On the other
hand, if lf[0] = 0 and lf[1] = 1, only DMP1 will change the trajectory
to match the trajectory of DMP0, again at the distance dd and again
only after learning. Vice versa applies as well. Leader-follower
relation can be determined by a higher-level planner [..].</dd>
<dt><strong><code>k</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1)</code></dt>
<dd>Virtual spring constant that couples the positions.</dd>
<dt><strong><code>c1</code></strong> :&ensp;<code>float</code>, optional <code>(default: 100)</code></dt>
<dd>Scaling factor for spring forces in the velocity component and
acceleration component.</dd>
<dt><strong><code>c2</code></strong> :&ensp;<code>float</code>, optional <code>(default: 30)</code></dt>
<dd>Scaling factor for spring forces in the acceleration component.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CouplingTermPos3DToPos3D:  # for DMP
    &#34;&#34;&#34;Couples position components of a 6D DMP with a virtual spring in 3D.

    A. Gams, B. Nemec, L. Zlajpah, M. Wchter, T. Asfour, A. Ude:
    Modulation of Motor Primitives using Force Feedback: Interaction with
    the Environment and Bimanual Tasks (2013), IROS,
    https://h2t.anthropomatik.kit.edu/pdf/Gams2013.pdf

    Parameters
    ----------
    desired_distance : array, shape (3,)
        Desired distance between components.

    lf : array-like, shape (2,)
        Binary values that indicate which DMP(s) will be adapted.
        The variable lf defines the relation leader-follower. If lf[0] = lf[1],
        then both robots will adapt their trajectories to follow average
        trajectories at the defined distance dd between them [..]. On the other
        hand, if lf[0] = 0 and lf[1] = 1, only DMP1 will change the trajectory
        to match the trajectory of DMP0, again at the distance dd and again
        only after learning. Vice versa applies as well. Leader-follower
        relation can be determined by a higher-level planner [..].

    k : float, optional (default: 1)
        Virtual spring constant that couples the positions.

    c1 : float, optional (default: 100)
        Scaling factor for spring forces in the velocity component and
        acceleration component.

    c2 : float, optional (default: 30)
        Scaling factor for spring forces in the acceleration component.
    &#34;&#34;&#34;
    def __init__(self, desired_distance, lf, k=1.0, c1=1.0, c2=30.0):
        self.desired_distance = desired_distance
        self.lf = lf
        self.k = k
        self.c1 = c1
        self.c2 = c2

    def coupling(self, y, yd=None):
        da = y[:3] - y[3:6]
        # Why do we take -self.desired_distance here? Because this allows us
        # to regard the desired distance as the displacement of DMP1 with
        # respect to DMP0.
        F12 = self.k * (-self.desired_distance - da)
        F21 = -F12
        C12 = self.c1 * F12 * self.lf[0]
        C21 = self.c1 * F21 * self.lf[1]
        C12dot = F12 * self.c2 * self.lf[0]
        C21dot = F21 * self.c2 * self.lf[1]
        return np.hstack([C12, C21]), np.hstack([C12dot, C21dot])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.CouplingTermPos3DToPos3D.coupling"><code class="name flex">
<span>def <span class="ident">coupling</span></span>(<span>self, y, yd=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coupling(self, y, yd=None):
    da = y[:3] - y[3:6]
    # Why do we take -self.desired_distance here? Because this allows us
    # to regard the desired distance as the displacement of DMP1 with
    # respect to DMP0.
    F12 = self.k * (-self.desired_distance - da)
    F21 = -F12
    C12 = self.c1 * F12 * self.lf[0]
    C21 = self.c1 * F21 * self.lf[1]
    C12dot = F12 * self.c2 * self.lf[0]
    C21dot = F21 * self.c2 * self.lf[1]
    return np.hstack([C12, C21]), np.hstack([C12dot, C21dot])</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="movement_primitives.dmp.DMP"><code class="flex name class">
<span>class <span class="ident">DMP</span></span>
<span>(</span><span>n_dims, execution_time=1.0, dt=0.01, n_weights_per_dim=10, int_dt=0.001, p_gain=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Dynamical movement primitive (DMP).</p>
<p>Implementation according to</p>
<p>A.J. Ijspeert, J. Nakanishi, H. Hoffmann, P. Pastor, S. Schaal:
Dynamical Movement Primitives: Learning Attractor Models for Motor
Behaviors (2013), Neural Computation 25(2), pp. 328-373, doi:
10.1162/NECO_a_00393, <a href="https://ieeexplore.ieee.org/document/6797340">https://ieeexplore.ieee.org/document/6797340</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_dims</code></strong> :&ensp;<code>int</code></dt>
<dd>State space dimensions.</dd>
<dt><strong><code>execution_time</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1)</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.01)</code></dt>
<dd>Time difference between DMP steps.</dd>
<dt><strong><code>n_weights_per_dim</code></strong> :&ensp;<code>int</code>, optional <code>(default: 10)</code></dt>
<dd>Number of weights of the function approximator per dimension.</dd>
<dt><strong><code>int_dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.001)</code></dt>
<dd>Time difference for Euler integration.</dd>
<dt><strong><code>p_gain</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Gain for proportional controller of DMP tracking error.
The domain is [0, execution_time**2/dt].</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>execution_time_</code></strong> :&ensp;<code>float</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt_</code></strong> :&ensp;<code>float</code></dt>
<dd>Time difference between DMP steps. This value can be changed to adapt
the frequency.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMP(WeightParametersMixin, DMPBase):
    &#34;&#34;&#34;Dynamical movement primitive (DMP).

    Implementation according to

    A.J. Ijspeert, J. Nakanishi, H. Hoffmann, P. Pastor, S. Schaal:
    Dynamical Movement Primitives: Learning Attractor Models for Motor
    Behaviors (2013), Neural Computation 25(2), pp. 328-373, doi:
    10.1162/NECO_a_00393, https://ieeexplore.ieee.org/document/6797340

    Parameters
    ----------
    n_dims : int
        State space dimensions.

    execution_time : float, optional (default: 1)
        Execution time of the DMP.

    dt : float, optional (default: 0.01)
        Time difference between DMP steps.

    n_weights_per_dim : int, optional (default: 10)
        Number of weights of the function approximator per dimension.

    int_dt : float, optional (default: 0.001)
        Time difference for Euler integration.

    p_gain : float, optional (default: 0)
        Gain for proportional controller of DMP tracking error.
        The domain is [0, execution_time**2/dt].

    Attributes
    ----------
    execution_time_ : float
        Execution time of the DMP.

    dt_ : float
        Time difference between DMP steps. This value can be changed to adapt
        the frequency.
    &#34;&#34;&#34;
    def __init__(self, n_dims, execution_time=1.0, dt=0.01,
                 n_weights_per_dim=10, int_dt=0.001, p_gain=0.0):
        super(DMP, self).__init__(n_dims, n_dims)
        self._execution_time = execution_time
        self.dt_ = dt
        self.n_weights_per_dim = n_weights_per_dim
        self.int_dt = int_dt
        self.p_gain = p_gain

        self._init_forcing_term()

        self.alpha_y = 25.0
        self.beta_y = self.alpha_y / 4.0

    def _init_forcing_term(self):
        alpha_z = canonical_system_alpha(
            0.01, self.execution_time_, 0.0, self.int_dt)
        self.forcing_term = ForcingTerm(
            self.n_dims, self.n_weights_per_dim, self.execution_time_,
            0.0, 0.8, alpha_z)

    def get_execution_time_(self):
        return self._execution_time

    def set_execution_time_(self, execution_time):
        self._execution_time = execution_time
        weights = self.forcing_term.weights_
        self._init_forcing_term()
        self.forcing_term.weights_ = weights

    execution_time_ = property(get_execution_time_, set_execution_time_)

    def step(self, last_y, last_yd, coupling_term=None,
             step_function=DEFAULT_DMP_STEP_FUNCTION):
        &#34;&#34;&#34;DMP step.

        Parameters
        ----------
        last_y : array, shape (n_dims,)
            Last state.

        last_yd : array, shape (n_dims,)
            Last time derivative of state (e.g., velocity).

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        step_function : str, optional (default: &#39;rk4-cython&#39;)
            DMP integration function. Possible options: &#39;rk4&#39;, &#39;euler&#39;,
            &#39;euler-cython&#39;, &#39;rk4-cython&#39;.

        Returns
        -------
        y : array, shape (n_dims,)
            Next state.

        yd : array, shape (n_dims,)
            Next time derivative of state (e.g., velocity).
        &#34;&#34;&#34;
        try:
            step_function = DMP_STEP_FUNCTIONS[step_function]
        except KeyError:
            raise ValueError(
                f&#34;Step function must be in {DMP_STEP_FUNCTIONS.keys()}.&#34;)

        assert len(last_y) == self.n_dims
        assert len(last_yd) == self.n_dims
        self.last_t = self.t
        self.t += self.dt_

        if not self.initialized:
            self.current_y = np.copy(self.start_y)
            self.current_yd = np.copy(self.start_yd)
            self.initialized = True

        # https://github.com/studywolf/pydmps/blob/master/pydmps/cs.py
        tracking_error = self.current_y - last_y

        step_function(
            self.last_t, self.t,
            self.current_y, self.current_yd,
            self.goal_y, self.goal_yd, self.goal_ydd,
            self.start_y, self.start_yd, self.start_ydd,
            self.execution_time_, 0.0,
            self.alpha_y, self.beta_y,
            self.forcing_term,
            coupling_term=coupling_term,
            int_dt=self.int_dt,
            p_gain=self.p_gain,
            tracking_error=tracking_error)
        return np.copy(self.current_y), np.copy(self.current_yd)

    def open_loop(self, run_t=None, coupling_term=None,
                  step_function=DEFAULT_DMP_STEP_FUNCTION):
        &#34;&#34;&#34;Run DMP open loop.

        Parameters
        ----------
        run_t : float, optional (default: execution_time)
            Run time of DMP. Can be shorter or longer than execution_time.

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        step_function : str, optional (default: &#39;rk4-cython&#39;)
            DMP integration function. Possible options: &#39;rk4&#39;, &#39;euler&#39;,
            &#39;euler-cython&#39;, &#39;rk4-cython&#39;.

        Returns
        -------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, n_dims)
            State at each step.

        Raises
        ------
        ValueError
            If step function is unknown.
        &#34;&#34;&#34;
        try:
            step_function = DMP_STEP_FUNCTIONS[step_function]
        except KeyError:
            raise ValueError(
                f&#34;Step function must be in {DMP_STEP_FUNCTIONS.keys()}.&#34;)

        return dmp_open_loop(
            self.execution_time_, 0.0, self.dt_,
            self.start_y, self.goal_y,
            self.alpha_y, self.beta_y,
            self.forcing_term,
            coupling_term,
            run_t, self.int_dt,
            step_function)

    def imitate(self, T, Y, regularization_coefficient=0.0,
                allow_final_velocity=False):
        &#34;&#34;&#34;Imitate demonstration.

        Parameters
        ----------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, n_dims)
            State at each step.

        regularization_coefficient : float, optional (default: 0)
            Regularization coefficient for regression.

        allow_final_velocity : bool, optional (default: False)
            Allow a final velocity.
        &#34;&#34;&#34;
        self.forcing_term.weights_[:, :], start_y, _, _, goal_y, _, _ = dmp_imitate(
            T, Y,
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y, overlap=self.forcing_term.overlap,
            alpha_z=self.forcing_term.alpha_z, allow_final_velocity=allow_final_velocity)
        self.configure(start_y=start_y, goal_y=goal_y)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>movement_primitives.dmp._base.WeightParametersMixin</li>
<li>movement_primitives.dmp._base.DMPBase</li>
<li><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="movement_primitives.dmp.DMP.execution_time_"><code class="name">var <span class="ident">execution_time_</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.DMP.get_execution_time_"><code class="name flex">
<span>def <span class="ident">get_execution_time_</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMP.imitate"><code class="name flex">
<span>def <span class="ident">imitate</span></span>(<span>self, T, Y, regularization_coefficient=0.0, allow_final_velocity=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imitate demonstration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, n_dims)</code></dt>
<dd>State at each step.</dd>
<dt><strong><code>regularization_coefficient</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Regularization coefficient for regression.</dd>
<dt><strong><code>allow_final_velocity</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Allow a final velocity.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imitate(self, T, Y, regularization_coefficient=0.0,
            allow_final_velocity=False):
    &#34;&#34;&#34;Imitate demonstration.

    Parameters
    ----------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, n_dims)
        State at each step.

    regularization_coefficient : float, optional (default: 0)
        Regularization coefficient for regression.

    allow_final_velocity : bool, optional (default: False)
        Allow a final velocity.
    &#34;&#34;&#34;
    self.forcing_term.weights_[:, :], start_y, _, _, goal_y, _, _ = dmp_imitate(
        T, Y,
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y, overlap=self.forcing_term.overlap,
        alpha_z=self.forcing_term.alpha_z, allow_final_velocity=allow_final_velocity)
    self.configure(start_y=start_y, goal_y=goal_y)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMP.open_loop"><code class="name flex">
<span>def <span class="ident">open_loop</span></span>(<span>self, run_t=None, coupling_term=None, step_function='rk4-cython')</span>
</code></dt>
<dd>
<div class="desc"><p>Run DMP open loop.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>run_t</code></strong> :&ensp;<code>float</code>, optional <code>(default: execution_time)</code></dt>
<dd>Run time of DMP. Can be shorter or longer than execution_time.</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
<dt><strong><code>step_function</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'rk4-cython')</code></dt>
<dd>DMP integration function. Possible options: 'rk4', 'euler',
'euler-cython', 'rk4-cython'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, n_dims)</code></dt>
<dd>State at each step.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If step function is unknown.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_loop(self, run_t=None, coupling_term=None,
              step_function=DEFAULT_DMP_STEP_FUNCTION):
    &#34;&#34;&#34;Run DMP open loop.

    Parameters
    ----------
    run_t : float, optional (default: execution_time)
        Run time of DMP. Can be shorter or longer than execution_time.

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    step_function : str, optional (default: &#39;rk4-cython&#39;)
        DMP integration function. Possible options: &#39;rk4&#39;, &#39;euler&#39;,
        &#39;euler-cython&#39;, &#39;rk4-cython&#39;.

    Returns
    -------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, n_dims)
        State at each step.

    Raises
    ------
    ValueError
        If step function is unknown.
    &#34;&#34;&#34;
    try:
        step_function = DMP_STEP_FUNCTIONS[step_function]
    except KeyError:
        raise ValueError(
            f&#34;Step function must be in {DMP_STEP_FUNCTIONS.keys()}.&#34;)

    return dmp_open_loop(
        self.execution_time_, 0.0, self.dt_,
        self.start_y, self.goal_y,
        self.alpha_y, self.beta_y,
        self.forcing_term,
        coupling_term,
        run_t, self.int_dt,
        step_function)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMP.set_execution_time_"><code class="name flex">
<span>def <span class="ident">set_execution_time_</span></span>(<span>self, execution_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_execution_time_(self, execution_time):
    self._execution_time = execution_time
    weights = self.forcing_term.weights_
    self._init_forcing_term()
    self.forcing_term.weights_ = weights</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMP.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, last_y, last_yd, coupling_term=None, step_function='rk4-cython')</span>
</code></dt>
<dd>
<div class="desc"><p>DMP step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>last_y</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Last state.</dd>
<dt><strong><code>last_yd</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Last time derivative of state (e.g., velocity).</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
<dt><strong><code>step_function</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'rk4-cython')</code></dt>
<dd>DMP integration function. Possible options: 'rk4', 'euler',
'euler-cython', 'rk4-cython'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Next state.</dd>
<dt><strong><code>yd</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Next time derivative of state (e.g., velocity).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, last_y, last_yd, coupling_term=None,
         step_function=DEFAULT_DMP_STEP_FUNCTION):
    &#34;&#34;&#34;DMP step.

    Parameters
    ----------
    last_y : array, shape (n_dims,)
        Last state.

    last_yd : array, shape (n_dims,)
        Last time derivative of state (e.g., velocity).

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    step_function : str, optional (default: &#39;rk4-cython&#39;)
        DMP integration function. Possible options: &#39;rk4&#39;, &#39;euler&#39;,
        &#39;euler-cython&#39;, &#39;rk4-cython&#39;.

    Returns
    -------
    y : array, shape (n_dims,)
        Next state.

    yd : array, shape (n_dims,)
        Next time derivative of state (e.g., velocity).
    &#34;&#34;&#34;
    try:
        step_function = DMP_STEP_FUNCTIONS[step_function]
    except KeyError:
        raise ValueError(
            f&#34;Step function must be in {DMP_STEP_FUNCTIONS.keys()}.&#34;)

    assert len(last_y) == self.n_dims
    assert len(last_yd) == self.n_dims
    self.last_t = self.t
    self.t += self.dt_

    if not self.initialized:
        self.current_y = np.copy(self.start_y)
        self.current_yd = np.copy(self.start_yd)
        self.initialized = True

    # https://github.com/studywolf/pydmps/blob/master/pydmps/cs.py
    tracking_error = self.current_y - last_y

    step_function(
        self.last_t, self.t,
        self.current_y, self.current_yd,
        self.goal_y, self.goal_yd, self.goal_ydd,
        self.start_y, self.start_yd, self.start_ydd,
        self.execution_time_, 0.0,
        self.alpha_y, self.beta_y,
        self.forcing_term,
        coupling_term=coupling_term,
        int_dt=self.int_dt,
        p_gain=self.p_gain,
        tracking_error=tracking_error)
    return np.copy(self.current_y), np.copy(self.current_yd)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></b></code>:
<ul class="hlist">
<li><code><a title="movement_primitives.base.PointToPointMovement.configure" href="../base.html#movement_primitives.base.PointToPointMovement.configure">configure</a></code></li>
<li><code><a title="movement_primitives.base.PointToPointMovement.n_steps_open_loop" href="../base.html#movement_primitives.base.PointToPointMovement.n_steps_open_loop">n_steps_open_loop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity"><code class="flex name class">
<span>class <span class="ident">DMPWithFinalVelocity</span></span>
<span>(</span><span>n_dims, execution_time=1.0, dt=0.01, n_weights_per_dim=10, int_dt=0.001, p_gain=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Dynamical movement primitive (DMP) with final velocity.</p>
<p>Implementation according to</p>
<p>K. Muelling, J. Kober, O. Kroemer, J. Peters:
Learning to Select and Generalize Striking Movements in Robot Table Tennis
(2013), International Journal of Robotics Research 32(3), pp. 263-279,
<a href="https://www.ias.informatik.tu-darmstadt.de/uploads/Publications/Muelling_IJRR_2013.pdf">https://www.ias.informatik.tu-darmstadt.de/uploads/Publications/Muelling_IJRR_2013.pdf</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_dims</code></strong> :&ensp;<code>int</code></dt>
<dd>State space dimensions.</dd>
<dt><strong><code>execution_time</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1)</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.01)</code></dt>
<dd>Time difference between DMP steps.</dd>
<dt><strong><code>n_weights_per_dim</code></strong> :&ensp;<code>int</code>, optional <code>(default: 10)</code></dt>
<dd>Number of weights of the function approximator per dimension.</dd>
<dt><strong><code>int_dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.001)</code></dt>
<dd>Time difference for Euler integration.</dd>
<dt><strong><code>p_gain</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Gain for proportional controller of DMP tracking error.
The domain is [0, execution_time**2/dt].</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>execution_time_</code></strong> :&ensp;<code>float</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt_</code></strong> :&ensp;<code>float</code></dt>
<dd>Time difference between DMP steps. This value can be changed to adapt
the frequency.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMPWithFinalVelocity(WeightParametersMixin, DMPBase):
    &#34;&#34;&#34;Dynamical movement primitive (DMP) with final velocity.

    Implementation according to

    K. Muelling, J. Kober, O. Kroemer, J. Peters:
    Learning to Select and Generalize Striking Movements in Robot Table Tennis
    (2013), International Journal of Robotics Research 32(3), pp. 263-279,
    https://www.ias.informatik.tu-darmstadt.de/uploads/Publications/Muelling_IJRR_2013.pdf

    Parameters
    ----------
    n_dims : int
        State space dimensions.

    execution_time : float, optional (default: 1)
        Execution time of the DMP.

    dt : float, optional (default: 0.01)
        Time difference between DMP steps.

    n_weights_per_dim : int, optional (default: 10)
        Number of weights of the function approximator per dimension.

    int_dt : float, optional (default: 0.001)
        Time difference for Euler integration.

    p_gain : float, optional (default: 0)
        Gain for proportional controller of DMP tracking error.
        The domain is [0, execution_time**2/dt].

    Attributes
    ----------
    execution_time_ : float
        Execution time of the DMP.

    dt_ : float
        Time difference between DMP steps. This value can be changed to adapt
        the frequency.
    &#34;&#34;&#34;
    def __init__(self, n_dims, execution_time=1.0, dt=0.01,
                 n_weights_per_dim=10, int_dt=0.001, p_gain=0.0):
        super(DMPWithFinalVelocity, self).__init__(n_dims, n_dims)
        self._execution_time = execution_time
        self.dt_ = dt
        self.n_weights_per_dim = n_weights_per_dim
        self.int_dt = int_dt
        self.p_gain = p_gain

        self._init_forcing_term()

        self.alpha_y = 25.0
        self.beta_y = self.alpha_y / 4.0

    def _init_forcing_term(self):
        alpha_z = canonical_system_alpha(0.01, self.execution_time_, 0.0,
                                         self.int_dt)
        self.forcing_term = ForcingTerm(
            self.n_dims, self.n_weights_per_dim, self.execution_time_,
            0.0, 0.8, alpha_z)

    def get_execution_time_(self):
        return self._execution_time

    def set_execution_time_(self, execution_time):
        self._execution_time = execution_time
        weights = self.forcing_term.weights_
        self._init_forcing_term()
        self.forcing_term.weights_ = weights

    execution_time_ = property(get_execution_time_, set_execution_time_)

    def step(self, last_y, last_yd, coupling_term=None):
        &#34;&#34;&#34;DMP step.

        Parameters
        ----------
        last_y : array, shape (n_dims,)
            Last state.

        last_yd : array, shape (n_dims,)
            Last time derivative of state (e.g., velocity).

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        Returns
        -------
        y : array, shape (n_dims,)
            Next state.

        yd : array, shape (n_dims,)
            Next time derivative of state (e.g., velocity).
        &#34;&#34;&#34;
        self.last_t = self.t
        self.t += self.dt_

        if not self.initialized:
            self.current_y = np.copy(self.start_y)
            self.current_yd = np.copy(self.start_yd)
            self.initialized = True

        # https://github.com/studywolf/pydmps/blob/master/pydmps/cs.py
        tracking_error = self.current_y - last_y

        dmp_step_euler_with_constraints(
            self.last_t, self.t,
            self.current_y, self.current_yd,
            self.goal_y, self.goal_yd, self.goal_ydd,
            self.start_y, self.start_yd, self.start_ydd,
            self.execution_time_, 0.0,
            self.alpha_y, self.beta_y,
            self.forcing_term,
            coupling_term=coupling_term,
            int_dt=self.int_dt,
            p_gain=self.p_gain,
            tracking_error=tracking_error)
        return np.copy(self.current_y), np.copy(self.current_yd)

    def open_loop(self, run_t=None, coupling_term=None):
        &#34;&#34;&#34;Run DMP open loop.

        Parameters
        ----------
        run_t : float, optional (default: execution_time)
            Run time of DMP. Can be shorter or longer than execution_time.

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        Returns
        -------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, n_dims)
            State at each step.
        &#34;&#34;&#34;
        return dmp_open_loop(
            self.execution_time_, 0.0, self.dt_,
            self.start_y, self.goal_y,
            self.alpha_y, self.beta_y,
            self.forcing_term,
            coupling_term,
            run_t, self.int_dt,
            dmp_step_euler_with_constraints,
            start_yd=self.start_yd, start_ydd=self.start_ydd,
            goal_yd=self.goal_yd, goal_ydd=self.goal_ydd)

    def imitate(self, T, Y, regularization_coefficient=0.0):
        &#34;&#34;&#34;Imitate demonstration.

        Parameters
        ----------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, n_dims)
            State at each step.

        regularization_coefficient : float, optional (default: 0)
            Regularization coefficient for regression.
        &#34;&#34;&#34;
        self.forcing_term.weights_[:, :], start_y, start_yd, start_ydd, goal_y, goal_yd, goal_ydd = dmp_imitate(
            T, Y,
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term.overlap,
            alpha_z=self.forcing_term.alpha_z, allow_final_velocity=True,
            determine_forces=determine_forces)
        self.configure(
            start_y=start_y, start_yd=start_yd, start_ydd=start_ydd,
            goal_y=goal_y, goal_yd=goal_yd, goal_ydd=goal_ydd)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>movement_primitives.dmp._base.WeightParametersMixin</li>
<li>movement_primitives.dmp._base.DMPBase</li>
<li><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity.execution_time_"><code class="name">var <span class="ident">execution_time_</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity.get_execution_time_"><code class="name flex">
<span>def <span class="ident">get_execution_time_</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity.imitate"><code class="name flex">
<span>def <span class="ident">imitate</span></span>(<span>self, T, Y, regularization_coefficient=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Imitate demonstration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, n_dims)</code></dt>
<dd>State at each step.</dd>
<dt><strong><code>regularization_coefficient</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Regularization coefficient for regression.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imitate(self, T, Y, regularization_coefficient=0.0):
    &#34;&#34;&#34;Imitate demonstration.

    Parameters
    ----------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, n_dims)
        State at each step.

    regularization_coefficient : float, optional (default: 0)
        Regularization coefficient for regression.
    &#34;&#34;&#34;
    self.forcing_term.weights_[:, :], start_y, start_yd, start_ydd, goal_y, goal_yd, goal_ydd = dmp_imitate(
        T, Y,
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term.overlap,
        alpha_z=self.forcing_term.alpha_z, allow_final_velocity=True,
        determine_forces=determine_forces)
    self.configure(
        start_y=start_y, start_yd=start_yd, start_ydd=start_ydd,
        goal_y=goal_y, goal_yd=goal_yd, goal_ydd=goal_ydd)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity.open_loop"><code class="name flex">
<span>def <span class="ident">open_loop</span></span>(<span>self, run_t=None, coupling_term=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Run DMP open loop.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>run_t</code></strong> :&ensp;<code>float</code>, optional <code>(default: execution_time)</code></dt>
<dd>Run time of DMP. Can be shorter or longer than execution_time.</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, n_dims)</code></dt>
<dd>State at each step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_loop(self, run_t=None, coupling_term=None):
    &#34;&#34;&#34;Run DMP open loop.

    Parameters
    ----------
    run_t : float, optional (default: execution_time)
        Run time of DMP. Can be shorter or longer than execution_time.

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    Returns
    -------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, n_dims)
        State at each step.
    &#34;&#34;&#34;
    return dmp_open_loop(
        self.execution_time_, 0.0, self.dt_,
        self.start_y, self.goal_y,
        self.alpha_y, self.beta_y,
        self.forcing_term,
        coupling_term,
        run_t, self.int_dt,
        dmp_step_euler_with_constraints,
        start_yd=self.start_yd, start_ydd=self.start_ydd,
        goal_yd=self.goal_yd, goal_ydd=self.goal_ydd)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity.set_execution_time_"><code class="name flex">
<span>def <span class="ident">set_execution_time_</span></span>(<span>self, execution_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_execution_time_(self, execution_time):
    self._execution_time = execution_time
    weights = self.forcing_term.weights_
    self._init_forcing_term()
    self.forcing_term.weights_ = weights</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DMPWithFinalVelocity.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, last_y, last_yd, coupling_term=None)</span>
</code></dt>
<dd>
<div class="desc"><p>DMP step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>last_y</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Last state.</dd>
<dt><strong><code>last_yd</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Last time derivative of state (e.g., velocity).</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Next state.</dd>
<dt><strong><code>yd</code></strong> :&ensp;<code>array, shape (n_dims,)</code></dt>
<dd>Next time derivative of state (e.g., velocity).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, last_y, last_yd, coupling_term=None):
    &#34;&#34;&#34;DMP step.

    Parameters
    ----------
    last_y : array, shape (n_dims,)
        Last state.

    last_yd : array, shape (n_dims,)
        Last time derivative of state (e.g., velocity).

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    Returns
    -------
    y : array, shape (n_dims,)
        Next state.

    yd : array, shape (n_dims,)
        Next time derivative of state (e.g., velocity).
    &#34;&#34;&#34;
    self.last_t = self.t
    self.t += self.dt_

    if not self.initialized:
        self.current_y = np.copy(self.start_y)
        self.current_yd = np.copy(self.start_yd)
        self.initialized = True

    # https://github.com/studywolf/pydmps/blob/master/pydmps/cs.py
    tracking_error = self.current_y - last_y

    dmp_step_euler_with_constraints(
        self.last_t, self.t,
        self.current_y, self.current_yd,
        self.goal_y, self.goal_yd, self.goal_ydd,
        self.start_y, self.start_yd, self.start_ydd,
        self.execution_time_, 0.0,
        self.alpha_y, self.beta_y,
        self.forcing_term,
        coupling_term=coupling_term,
        int_dt=self.int_dt,
        p_gain=self.p_gain,
        tracking_error=tracking_error)
    return np.copy(self.current_y), np.copy(self.current_yd)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></b></code>:
<ul class="hlist">
<li><code><a title="movement_primitives.base.PointToPointMovement.configure" href="../base.html#movement_primitives.base.PointToPointMovement.configure">configure</a></code></li>
<li><code><a title="movement_primitives.base.PointToPointMovement.n_steps_open_loop" href="../base.html#movement_primitives.base.PointToPointMovement.n_steps_open_loop">n_steps_open_loop</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="movement_primitives.dmp.DualCartesianDMP"><code class="flex name class">
<span>class <span class="ident">DualCartesianDMP</span></span>
<span>(</span><span>execution_time=1.0, dt=0.01, n_weights_per_dim=10, int_dt=0.001, p_gain=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Dual cartesian dynamical movement primitive.</p>
<p>Each of the two Cartesian DMPs handles orientation and position separately.
The orientation is represented by a quaternion. The quaternion DMP is
implemented according to</p>
<p>A. Ude, B. Nemec, T. Petric, J. Murimoto:
Orientation in Cartesian space dynamic movement primitives (2014),
IEEE International Conference on Robotics and Automation (ICRA),
pp. 2997-3004, doi: 10.1109/ICRA.2014.6907291,
<a href="https://ieeexplore.ieee.org/document/6907291">https://ieeexplore.ieee.org/document/6907291</a></p>
<p>While the dimension of the state space is 14, the dimension of the
velocity, acceleration, and forcing term is 12.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>execution_time</code></strong> :&ensp;<code>float</code>, optional <code>(default: 1)</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.01)</code></dt>
<dd>Time difference between DMP steps.</dd>
<dt><strong><code>n_weights_per_dim</code></strong> :&ensp;<code>int</code>, optional <code>(default: 10)</code></dt>
<dd>Number of weights of the function approximator per dimension.</dd>
<dt><strong><code>int_dt</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0.001)</code></dt>
<dd>Time difference for Euler integration.</dd>
<dt><strong><code>p_gain</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Gain for proportional controller of DMP tracking error.
The domain is [0, execution_time**2/dt].</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>execution_time_</code></strong> :&ensp;<code>float</code></dt>
<dd>Execution time of the DMP.</dd>
<dt><strong><code>dt_</code></strong> :&ensp;<code>float</code></dt>
<dd>Time difference between DMP steps. This value can be changed to adapt
the frequency.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DualCartesianDMP(WeightParametersMixin, DMPBase):
    &#34;&#34;&#34;Dual cartesian dynamical movement primitive.

    Each of the two Cartesian DMPs handles orientation and position separately.
    The orientation is represented by a quaternion. The quaternion DMP is
    implemented according to

    A. Ude, B. Nemec, T. Petric, J. Murimoto:
    Orientation in Cartesian space dynamic movement primitives (2014),
    IEEE International Conference on Robotics and Automation (ICRA),
    pp. 2997-3004, doi: 10.1109/ICRA.2014.6907291,
    https://ieeexplore.ieee.org/document/6907291

    While the dimension of the state space is 14, the dimension of the
    velocity, acceleration, and forcing term is 12.

    Parameters
    ----------
    execution_time : float, optional (default: 1)
        Execution time of the DMP.

    dt : float, optional (default: 0.01)
        Time difference between DMP steps.

    n_weights_per_dim : int, optional (default: 10)
        Number of weights of the function approximator per dimension.

    int_dt : float, optional (default: 0.001)
        Time difference for Euler integration.

    p_gain : float, optional (default: 0)
        Gain for proportional controller of DMP tracking error.
        The domain is [0, execution_time**2/dt].

    Attributes
    ----------
    execution_time_ : float
        Execution time of the DMP.

    dt_ : float
        Time difference between DMP steps. This value can be changed to adapt
        the frequency.
    &#34;&#34;&#34;
    def __init__(self, execution_time=1.0, dt=0.01, n_weights_per_dim=10,
                 int_dt=0.001, p_gain=0.0):
        super(DualCartesianDMP, self).__init__(14, 12)
        self._execution_time = execution_time
        self.dt_ = dt
        self.n_weights_per_dim = n_weights_per_dim
        self.int_dt = int_dt
        self.p_gain = p_gain

        self._init_forcing_term()

        self.alpha_y = 25.0
        self.beta_y = self.alpha_y / 4.0

    def _init_forcing_term(self):
        alpha_z = canonical_system_alpha(
            0.01, self.execution_time_, 0.0, self.int_dt)
        self.forcing_term = ForcingTerm(
            12, self.n_weights_per_dim, self.execution_time_, 0.0, 0.8,
            alpha_z)

    def get_execution_time_(self):
        return self._execution_time

    def set_execution_time_(self, execution_time):
        self._execution_time = execution_time
        weights = self.forcing_term.weights_
        self._init_forcing_term()
        self.forcing_term.weights_ = weights

    execution_time_ = property(get_execution_time_, set_execution_time_)

    def step(self, last_y, last_yd, coupling_term=None,
             step_function=DUAL_CARTESIAN_DMP_STEP_FUNCTIONS[
                 DEFAULT_DUAL_CARTESIAN_DMP_STEP_FUNCTION]):
        &#34;&#34;&#34;DMP step.

        Parameters
        ----------
        last_y : array, shape (14,)
            Last state.

        last_yd : array, shape (12,)
            Last time derivative of state (velocity).

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        step_function : callable, optional (default: cython code if available)
            DMP integration function.

        Returns
        -------
        y : array, shape (14,)
            Next state.

        yd : array, shape (12,)
            Next time derivative of state (velocity).
        &#34;&#34;&#34;
        assert len(last_y) == self.n_dims
        assert len(last_yd) == 12

        self.last_t = self.t
        self.t += self.dt_

        if not self.initialized:
            self.current_y = np.copy(self.start_y)
            self.current_yd = np.copy(self.start_yd)
            self.initialized = True

        tracking_error = self.current_y - last_y
        for ops in (slice(3, 7), slice(10, 14)):
            tracking_error[ops] = pr.concatenate_quaternions(
                self.current_y[ops], pr.q_conj(last_y[ops]))
        self.current_y[:], self.current_yd[:] = last_y, last_yd
        step_function(
            self.last_t, self.t, self.current_y, self.current_yd,
            self.goal_y, self.goal_yd, self.goal_ydd,
            self.start_y, self.start_yd, self.start_ydd,
            self.execution_time_, 0.0,
            self.alpha_y, self.beta_y,
            self.forcing_term, coupling_term,
            self.int_dt,
            self.p_gain, tracking_error)

        return np.copy(self.current_y), np.copy(self.current_yd)

    def open_loop(self, run_t=None, coupling_term=None,
                  step_function=DEFAULT_DUAL_CARTESIAN_DMP_STEP_FUNCTION):
        &#34;&#34;&#34;Run DMP open loop.

        Parameters
        ----------
        run_t : float, optional (default: execution_time)
            Run time of DMP. Can be shorter or longer than execution_time.

        coupling_term : object, optional (default: None)
            Coupling term that will be added to velocity.

        step_function : str, optional (default: &#39;cython&#39; if available)
            DMP integration function. Possible options: &#39;python&#39;, &#39;cython&#39;.

        Returns
        -------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, 14)
            State at each step.
        &#34;&#34;&#34;
        try:
            step_function = DUAL_CARTESIAN_DMP_STEP_FUNCTIONS[step_function]
        except KeyError:
            raise ValueError(
                f&#34;Step function must be in &#34;
                f&#34;{DUAL_CARTESIAN_DMP_STEP_FUNCTIONS.keys()}.&#34;)

        if run_t is None:
            run_t = self.execution_time_
        self.t = 0.0
        T = [self.t]
        Y = [np.copy(self.start_y)]
        y = np.copy(self.start_y)
        yd = np.copy(self.start_yd)
        while self.t &lt; run_t:
            y, yd = self.step(y, yd, coupling_term, step_function)
            T.append(self.t)
            Y.append(np.copy(self.current_y))
        self.t = 0.0
        return np.array(T), np.vstack(Y)

    def imitate(self, T, Y, regularization_coefficient=0.0,
                allow_final_velocity=False):
        &#34;&#34;&#34;Imitate demonstration.

        Parameters
        ----------
        T : array, shape (n_steps,)
            Time for each step.

        Y : array, shape (n_steps, 14)
            State at each step.

        regularization_coefficient : float, optional (default: 0)
            Regularization coefficient for regression.

        allow_final_velocity : bool, optional (default: False)
            Allow a final velocity.
        &#34;&#34;&#34;
        self.forcing_term.weights_[:3, :] = dmp_imitate(
            T, Y[:, :3],
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term.overlap,
            alpha_z=self.forcing_term.alpha_z,
            allow_final_velocity=allow_final_velocity)[0]
        self.forcing_term.weights_[3:6, :] = dmp_quaternion_imitation(
            T, Y[:, 3:7],
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term.overlap,
            alpha_z=self.forcing_term.alpha_z,
            allow_final_velocity=allow_final_velocity)[0]
        self.forcing_term.weights_[6:9, :] = dmp_imitate(
            T, Y[:, 7:10],
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term.overlap,
            alpha_z=self.forcing_term.alpha_z,
            allow_final_velocity=allow_final_velocity)[0]
        self.forcing_term.weights_[9:12, :] = dmp_quaternion_imitation(
            T, Y[:, 10:14],
            n_weights_per_dim=self.n_weights_per_dim,
            regularization_coefficient=regularization_coefficient,
            alpha_y=self.alpha_y, beta_y=self.beta_y,
            overlap=self.forcing_term.overlap,
            alpha_z=self.forcing_term.alpha_z,
            allow_final_velocity=allow_final_velocity)[0]

        self.configure(start_y=Y[0], goal_y=Y[-1])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>movement_primitives.dmp._base.WeightParametersMixin</li>
<li>movement_primitives.dmp._base.DMPBase</li>
<li><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="movement_primitives.dmp.DualCartesianDMP.execution_time_"><code class="name">var <span class="ident">execution_time_</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="movement_primitives.dmp.DualCartesianDMP.get_execution_time_"><code class="name flex">
<span>def <span class="ident">get_execution_time_</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_execution_time_(self):
    return self._execution_time</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DualCartesianDMP.imitate"><code class="name flex">
<span>def <span class="ident">imitate</span></span>(<span>self, T, Y, regularization_coefficient=0.0, allow_final_velocity=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imitate demonstration.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, 14)</code></dt>
<dd>State at each step.</dd>
<dt><strong><code>regularization_coefficient</code></strong> :&ensp;<code>float</code>, optional <code>(default: 0)</code></dt>
<dd>Regularization coefficient for regression.</dd>
<dt><strong><code>allow_final_velocity</code></strong> :&ensp;<code>bool</code>, optional <code>(default: False)</code></dt>
<dd>Allow a final velocity.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def imitate(self, T, Y, regularization_coefficient=0.0,
            allow_final_velocity=False):
    &#34;&#34;&#34;Imitate demonstration.

    Parameters
    ----------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, 14)
        State at each step.

    regularization_coefficient : float, optional (default: 0)
        Regularization coefficient for regression.

    allow_final_velocity : bool, optional (default: False)
        Allow a final velocity.
    &#34;&#34;&#34;
    self.forcing_term.weights_[:3, :] = dmp_imitate(
        T, Y[:, :3],
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term.overlap,
        alpha_z=self.forcing_term.alpha_z,
        allow_final_velocity=allow_final_velocity)[0]
    self.forcing_term.weights_[3:6, :] = dmp_quaternion_imitation(
        T, Y[:, 3:7],
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term.overlap,
        alpha_z=self.forcing_term.alpha_z,
        allow_final_velocity=allow_final_velocity)[0]
    self.forcing_term.weights_[6:9, :] = dmp_imitate(
        T, Y[:, 7:10],
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term.overlap,
        alpha_z=self.forcing_term.alpha_z,
        allow_final_velocity=allow_final_velocity)[0]
    self.forcing_term.weights_[9:12, :] = dmp_quaternion_imitation(
        T, Y[:, 10:14],
        n_weights_per_dim=self.n_weights_per_dim,
        regularization_coefficient=regularization_coefficient,
        alpha_y=self.alpha_y, beta_y=self.beta_y,
        overlap=self.forcing_term.overlap,
        alpha_z=self.forcing_term.alpha_z,
        allow_final_velocity=allow_final_velocity)[0]

    self.configure(start_y=Y[0], goal_y=Y[-1])</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DualCartesianDMP.open_loop"><code class="name flex">
<span>def <span class="ident">open_loop</span></span>(<span>self, run_t=None, coupling_term=None, step_function='cython')</span>
</code></dt>
<dd>
<div class="desc"><p>Run DMP open loop.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>run_t</code></strong> :&ensp;<code>float</code>, optional <code>(default: execution_time)</code></dt>
<dd>Run time of DMP. Can be shorter or longer than execution_time.</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
<dt><strong><code>step_function</code></strong> :&ensp;<code>str</code>, optional <code>(default: 'cython' if available)</code></dt>
<dd>DMP integration function. Possible options: 'python', 'cython'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>T</code></strong> :&ensp;<code>array, shape (n_steps,)</code></dt>
<dd>Time for each step.</dd>
<dt><strong><code>Y</code></strong> :&ensp;<code>array, shape (n_steps, 14)</code></dt>
<dd>State at each step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_loop(self, run_t=None, coupling_term=None,
              step_function=DEFAULT_DUAL_CARTESIAN_DMP_STEP_FUNCTION):
    &#34;&#34;&#34;Run DMP open loop.

    Parameters
    ----------
    run_t : float, optional (default: execution_time)
        Run time of DMP. Can be shorter or longer than execution_time.

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    step_function : str, optional (default: &#39;cython&#39; if available)
        DMP integration function. Possible options: &#39;python&#39;, &#39;cython&#39;.

    Returns
    -------
    T : array, shape (n_steps,)
        Time for each step.

    Y : array, shape (n_steps, 14)
        State at each step.
    &#34;&#34;&#34;
    try:
        step_function = DUAL_CARTESIAN_DMP_STEP_FUNCTIONS[step_function]
    except KeyError:
        raise ValueError(
            f&#34;Step function must be in &#34;
            f&#34;{DUAL_CARTESIAN_DMP_STEP_FUNCTIONS.keys()}.&#34;)

    if run_t is None:
        run_t = self.execution_time_
    self.t = 0.0
    T = [self.t]
    Y = [np.copy(self.start_y)]
    y = np.copy(self.start_y)
    yd = np.copy(self.start_yd)
    while self.t &lt; run_t:
        y, yd = self.step(y, yd, coupling_term, step_function)
        T.append(self.t)
        Y.append(np.copy(self.current_y))
    self.t = 0.0
    return np.array(T), np.vstack(Y)</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DualCartesianDMP.set_execution_time_"><code class="name flex">
<span>def <span class="ident">set_execution_time_</span></span>(<span>self, execution_time)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_execution_time_(self, execution_time):
    self._execution_time = execution_time
    weights = self.forcing_term.weights_
    self._init_forcing_term()
    self.forcing_term.weights_ = weights</code></pre>
</details>
</dd>
<dt id="movement_primitives.dmp.DualCartesianDMP.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, last_y, last_yd, coupling_term=None, step_function=&lt;cyfunction dmp_step_dual_cartesian&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>DMP step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>last_y</code></strong> :&ensp;<code>array, shape (14,)</code></dt>
<dd>Last state.</dd>
<dt><strong><code>last_yd</code></strong> :&ensp;<code>array, shape (12,)</code></dt>
<dd>Last time derivative of state (velocity).</dd>
<dt><strong><code>coupling_term</code></strong> :&ensp;<code>object</code>, optional <code>(default: None)</code></dt>
<dd>Coupling term that will be added to velocity.</dd>
<dt><strong><code>step_function</code></strong> :&ensp;<code>callable</code>, optional <code>(default: cython code if available)</code></dt>
<dd>DMP integration function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array, shape (14,)</code></dt>
<dd>Next state.</dd>
<dt><strong><code>yd</code></strong> :&ensp;<code>array, shape (12,)</code></dt>
<dd>Next time derivative of state (velocity).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, last_y, last_yd, coupling_term=None,
         step_function=DUAL_CARTESIAN_DMP_STEP_FUNCTIONS[
             DEFAULT_DUAL_CARTESIAN_DMP_STEP_FUNCTION]):
    &#34;&#34;&#34;DMP step.

    Parameters
    ----------
    last_y : array, shape (14,)
        Last state.

    last_yd : array, shape (12,)
        Last time derivative of state (velocity).

    coupling_term : object, optional (default: None)
        Coupling term that will be added to velocity.

    step_function : callable, optional (default: cython code if available)
        DMP integration function.

    Returns
    -------
    y : array, shape (14,)
        Next state.

    yd : array, shape (12,)
        Next time derivative of state (velocity).
    &#34;&#34;&#34;
    assert len(last_y) == self.n_dims
    assert len(last_yd) == 12

    self.last_t = self.t
    self.t += self.dt_

    if not self.initialized:
        self.current_y = np.copy(self.start_y)
        self.current_yd = np.copy(self.start_yd)
        self.initialized = True

    tracking_error = self.current_y - last_y
    for ops in (slice(3, 7), slice(10, 14)):
        tracking_error[ops] = pr.concatenate_quaternions(
            self.current_y[ops], pr.q_conj(last_y[ops]))
    self.current_y[:], self.current_yd[:] = last_y, last_yd
    step_function(
        self.last_t, self.t, self.current_y, self.current_yd,
        self.goal_y, self.goal_yd, self.goal_ydd,
        self.start_y, self.start_yd, self.start_ydd,
        self.execution_time_, 0.0,
        self.alpha_y, self.beta_y,
        self.forcing_term, coupling_term,
        self.int_dt,
        self.p_gain, tracking_error)

    return np.copy(self.current_y), np.copy(self.current_yd)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="movement_primitives.base.PointToPointMovement" href="../base.html#movement_primitives.base.PointToPointMovement">PointToPointMovement</a></b></code>:
<ul class="hlist">
<li><code><a title="movement_primitives.base.PointToPointMovement.configure" href="../base.html#movement_primitives.base.PointToPointMovement.configure">configure</a></code></li>
<li><code><a title="movement_primitives.base.PointToPointMovement.n_steps_open_loop" href="../base.html#movement_primitives.base.PointToPointMovement.n_steps_open_loop">n_steps_open_loop</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="movement_primitives" href="../index.html">movement_primitives</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="movement_primitives.dmp.canonical_system_alpha" href="#movement_primitives.dmp.canonical_system_alpha">canonical_system_alpha</a></code></li>
<li><code><a title="movement_primitives.dmp.dmp_transformation_system" href="#movement_primitives.dmp.dmp_transformation_system">dmp_transformation_system</a></code></li>
<li><code><a title="movement_primitives.dmp.obstacle_avoidance_acceleration_2d" href="#movement_primitives.dmp.obstacle_avoidance_acceleration_2d">obstacle_avoidance_acceleration_2d</a></code></li>
<li><code><a title="movement_primitives.dmp.obstacle_avoidance_acceleration_3d" href="#movement_primitives.dmp.obstacle_avoidance_acceleration_3d">obstacle_avoidance_acceleration_3d</a></code></li>
<li><code><a title="movement_primitives.dmp.phase" href="#movement_primitives.dmp.phase">phase</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="movement_primitives.dmp.CartesianDMP" href="#movement_primitives.dmp.CartesianDMP">CartesianDMP</a></code></h4>
<ul class="two-column">
<li><code><a title="movement_primitives.dmp.CartesianDMP.execution_time_" href="#movement_primitives.dmp.CartesianDMP.execution_time_">execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.get_execution_time_" href="#movement_primitives.dmp.CartesianDMP.get_execution_time_">get_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.get_weights" href="#movement_primitives.dmp.CartesianDMP.get_weights">get_weights</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.imitate" href="#movement_primitives.dmp.CartesianDMP.imitate">imitate</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.open_loop" href="#movement_primitives.dmp.CartesianDMP.open_loop">open_loop</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.set_execution_time_" href="#movement_primitives.dmp.CartesianDMP.set_execution_time_">set_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.set_weights" href="#movement_primitives.dmp.CartesianDMP.set_weights">set_weights</a></code></li>
<li><code><a title="movement_primitives.dmp.CartesianDMP.step" href="#movement_primitives.dmp.CartesianDMP.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermDualCartesianDistance" href="#movement_primitives.dmp.CouplingTermDualCartesianDistance">CouplingTermDualCartesianDistance</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermDualCartesianDistance.coupling" href="#movement_primitives.dmp.CouplingTermDualCartesianDistance.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermDualCartesianOrientation" href="#movement_primitives.dmp.CouplingTermDualCartesianOrientation">CouplingTermDualCartesianOrientation</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermDualCartesianOrientation.coupling" href="#movement_primitives.dmp.CouplingTermDualCartesianOrientation.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermDualCartesianPose" href="#movement_primitives.dmp.CouplingTermDualCartesianPose">CouplingTermDualCartesianPose</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermDualCartesianPose.couple_distance" href="#movement_primitives.dmp.CouplingTermDualCartesianPose.couple_distance">couple_distance</a></code></li>
<li><code><a title="movement_primitives.dmp.CouplingTermDualCartesianPose.coupling" href="#movement_primitives.dmp.CouplingTermDualCartesianPose.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermDualCartesianTrajectory" href="#movement_primitives.dmp.CouplingTermDualCartesianTrajectory">CouplingTermDualCartesianTrajectory</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermDualCartesianTrajectory.coupling" href="#movement_primitives.dmp.CouplingTermDualCartesianTrajectory.coupling">coupling</a></code></li>
<li><code><a title="movement_primitives.dmp.CouplingTermDualCartesianTrajectory.imitate" href="#movement_primitives.dmp.CouplingTermDualCartesianTrajectory.imitate">imitate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermObstacleAvoidance2D" href="#movement_primitives.dmp.CouplingTermObstacleAvoidance2D">CouplingTermObstacleAvoidance2D</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermObstacleAvoidance2D.coupling" href="#movement_primitives.dmp.CouplingTermObstacleAvoidance2D.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermObstacleAvoidance3D" href="#movement_primitives.dmp.CouplingTermObstacleAvoidance3D">CouplingTermObstacleAvoidance3D</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermObstacleAvoidance3D.coupling" href="#movement_primitives.dmp.CouplingTermObstacleAvoidance3D.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermPos1DToPos1D" href="#movement_primitives.dmp.CouplingTermPos1DToPos1D">CouplingTermPos1DToPos1D</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermPos1DToPos1D.coupling" href="#movement_primitives.dmp.CouplingTermPos1DToPos1D.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.CouplingTermPos3DToPos3D" href="#movement_primitives.dmp.CouplingTermPos3DToPos3D">CouplingTermPos3DToPos3D</a></code></h4>
<ul class="">
<li><code><a title="movement_primitives.dmp.CouplingTermPos3DToPos3D.coupling" href="#movement_primitives.dmp.CouplingTermPos3DToPos3D.coupling">coupling</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.DMP" href="#movement_primitives.dmp.DMP">DMP</a></code></h4>
<ul class="two-column">
<li><code><a title="movement_primitives.dmp.DMP.execution_time_" href="#movement_primitives.dmp.DMP.execution_time_">execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DMP.get_execution_time_" href="#movement_primitives.dmp.DMP.get_execution_time_">get_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DMP.imitate" href="#movement_primitives.dmp.DMP.imitate">imitate</a></code></li>
<li><code><a title="movement_primitives.dmp.DMP.open_loop" href="#movement_primitives.dmp.DMP.open_loop">open_loop</a></code></li>
<li><code><a title="movement_primitives.dmp.DMP.set_execution_time_" href="#movement_primitives.dmp.DMP.set_execution_time_">set_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DMP.step" href="#movement_primitives.dmp.DMP.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.DMPWithFinalVelocity" href="#movement_primitives.dmp.DMPWithFinalVelocity">DMPWithFinalVelocity</a></code></h4>
<ul class="two-column">
<li><code><a title="movement_primitives.dmp.DMPWithFinalVelocity.execution_time_" href="#movement_primitives.dmp.DMPWithFinalVelocity.execution_time_">execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DMPWithFinalVelocity.get_execution_time_" href="#movement_primitives.dmp.DMPWithFinalVelocity.get_execution_time_">get_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DMPWithFinalVelocity.imitate" href="#movement_primitives.dmp.DMPWithFinalVelocity.imitate">imitate</a></code></li>
<li><code><a title="movement_primitives.dmp.DMPWithFinalVelocity.open_loop" href="#movement_primitives.dmp.DMPWithFinalVelocity.open_loop">open_loop</a></code></li>
<li><code><a title="movement_primitives.dmp.DMPWithFinalVelocity.set_execution_time_" href="#movement_primitives.dmp.DMPWithFinalVelocity.set_execution_time_">set_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DMPWithFinalVelocity.step" href="#movement_primitives.dmp.DMPWithFinalVelocity.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="movement_primitives.dmp.DualCartesianDMP" href="#movement_primitives.dmp.DualCartesianDMP">DualCartesianDMP</a></code></h4>
<ul class="two-column">
<li><code><a title="movement_primitives.dmp.DualCartesianDMP.execution_time_" href="#movement_primitives.dmp.DualCartesianDMP.execution_time_">execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DualCartesianDMP.get_execution_time_" href="#movement_primitives.dmp.DualCartesianDMP.get_execution_time_">get_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DualCartesianDMP.imitate" href="#movement_primitives.dmp.DualCartesianDMP.imitate">imitate</a></code></li>
<li><code><a title="movement_primitives.dmp.DualCartesianDMP.open_loop" href="#movement_primitives.dmp.DualCartesianDMP.open_loop">open_loop</a></code></li>
<li><code><a title="movement_primitives.dmp.DualCartesianDMP.set_execution_time_" href="#movement_primitives.dmp.DualCartesianDMP.set_execution_time_">set_execution_time_</a></code></li>
<li><code><a title="movement_primitives.dmp.DualCartesianDMP.step" href="#movement_primitives.dmp.DualCartesianDMP.step">step</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>